{"version":3,"sources":["FocusZone/FocusZone.tsx"],"names":["FocusZoneDirection","FocusZoneTabbableElements","IS_FOCUSABLE_ATTRIBUTE","React","cx","keyboardKey","ReactDOM","PropTypes","elementContains","getDocument","getParent","getWindow","getElementType","getUnhandledProps","getNextElement","getPreviousElement","isElementFocusZone","isElementFocusSubZone","isElementTabbable","getElementIndexPath","getFocusableByIndexPath","FOCUSZONE_ID_ATTRIBUTE","TABINDEX","LARGE_DISTANCE_FROM_CENTER","_allInstances","_outerZones","Set","ALLOWED_INPUT_TYPES","ALLOW_VIRTUAL_ELEMENTS","FocusZone","size","props","current","elem","_root","findDOMNode","setParkedFocus","ev","onActiveElementChanged","stopFocusPropagation","shouldFocusInnerElementWhenReceivedFocus","defaultTabbableElement","newActiveElement","isImmediateDescendant","isImmediateDescendantOfZone","target","parentElement","maybeElementToFocus","focus","_activeElement","setFocusAlignment","updateTabIndexes","stopPropagation","getCode","Tab","forEach","zone","disabled","path","push","length","pop","setActiveElement","direction","shouldEnterInnerZone","undefined","doc","onKeyDown","activeElement","_isInnerZone","isDefaultPrevented","innerZone","getFirstInnerZone","focusElement","firstChild","altKey","Spacebar","tryInvokeClickForFocusable","ArrowLeft","vertical","preventDefaultWhenHandled","moveFocusLeft","ArrowRight","moveFocusRight","ArrowUp","horizontal","moveFocusUp","ArrowDown","moveFocusDown","handleTabKey","all","inputOnly","isElementInput","focusChanged","_processingTabKey","shiftKey","bidirectional","tabWithDirection","isRtl","shouldResetActiveElementWhenTabFromZone","Home","isContentEditableElement","shouldInputLoseFocus","End","lastChild","Enter","preventDefault","_id","_focusAlignment","left","top","setRef","windowElement","body","nodeType","add","addEventListener","_onKeyDownCapture","_onBlur","shouldFocusOnMount","_lastIndexPath","restoreFocusFromRoot","elementToFocus","delete","removeEventListener","_defaultFocusElement","className","ElementType","unhandledProps","propTypes","evaluateFocusBeforeRender","_onKeyDown","_onFocus","_onMouseDown","children","forceIntoFirstElement","getAttribute","ownerZoneElement","getOwnerZone","ownerZone","element","shouldReceiveFocus","focusedElement","shouldRestoreFocus","isParked","_isParked","allowFocusRoot","_parkedTabIndex","setAttribute","removeAttribute","forceAlignemnt","previousActiveElement","tabIndex","forRootElement","rootElement","child","firstElementChild","match","nextElementSibling","isForward","getDistanceFromCenter","useDefaultWrap","candidateDistance","candidateElement","changedFocus","isBidirectional","activeRect","getBoundingClientRect","targetRect","elementDistance","isCircularNavigation","lastElementChild","targetTop","leftAlignment","moveFocus","distance","targetRectTop","Math","floor","activeRectBottom","bottom","width","abs","targetRectBottom","activeRectTop","topBottomComparison","parseFloat","toFixed","right","isHorizontal","isVertical","rect","height","onElement","childNodes","childIndex","tagName","toLowerCase","type","indexOf","selectionStart","selectionEnd","isRangeSelected","inputValue","value","shouldInputLoseFocusOnArrowKey","Component","string","number","func","bool","as","elementType","onFocus"],"mappings":"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","sourcesContent":["import { FocusZoneDirection, FocusZoneTabbableElements, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport * as React from 'react';\nimport cx from 'classnames';\nimport * as _ from 'lodash';\n// @ts-ignore\nimport * as keyboardKey from 'keyboard-key';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\n\nimport { elementContains, getDocument, getParent, getWindow } from '@uifabric/utilities';\n\nimport getElementType from '../utils/getElementType';\nimport getUnhandledProps from '../utils/getUnhandledProps';\nimport { FocusZoneProps, IFocusZone } from './FocusZone.types';\nimport {\n  getNextElement,\n  getPreviousElement,\n  isElementFocusZone,\n  isElementFocusSubZone,\n  isElementTabbable,\n  getElementIndexPath,\n  getFocusableByIndexPath,\n  FOCUSZONE_ID_ATTRIBUTE,\n} from './focusUtilities';\n\nconst TABINDEX = 'tabindex';\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\n\nconst _allInstances: {\n  [key: string]: FocusZone;\n} = {};\n\nconst _outerZones: Set<FocusZone> = new Set();\n\ninterface Point {\n  left: number;\n  top: number;\n}\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];\n\nconst ALLOW_VIRTUAL_ELEMENTS = false;\n\nexport default class FocusZone extends React.Component<FocusZoneProps> implements IFocusZone {\n  static propTypes = {\n    className: PropTypes.string,\n    direction: PropTypes.number,\n    defaultTabbableElement: PropTypes.func,\n    shouldFocusOnMount: PropTypes.bool,\n    shouldResetActiveElementWhenTabFromZone: PropTypes.bool,\n    shouldFocusInnerElementWhenReceivedFocus: PropTypes.bool,\n    disabled: PropTypes.bool,\n    as: PropTypes.elementType as PropTypes.Requireable<React.ElementType>,\n    isCircularNavigation: PropTypes.bool,\n    shouldEnterInnerZone: PropTypes.func,\n    onActiveElementChanged: PropTypes.func,\n    shouldReceiveFocus: PropTypes.func,\n    handleTabKey: PropTypes.number,\n    shouldInputLoseFocusOnArrowKey: PropTypes.func,\n    stopFocusPropagation: PropTypes.bool,\n    onFocus: PropTypes.func,\n    preventDefaultWhenHandled: PropTypes.bool,\n    isRtl: PropTypes.bool,\n    restoreFocusFromRoot: PropTypes.bool,\n  };\n\n  static defaultProps: FocusZoneProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    as: 'div',\n    preventDefaultWhenHandled: true,\n  };\n\n  static displayName = 'FocusZone';\n  static className = 'ms-FocusZone';\n\n  /** Used for testing purposes only. */\n  static getOuterZones(): number {\n    return _outerZones.size;\n  }\n\n  _root: { current: HTMLElement | null } = { current: null };\n  _id: string;\n  /** The most recently focused child element. */\n  _activeElement: HTMLElement | null;\n\n  /**\n   * The index path to the last focused child element.\n   */\n  _lastIndexPath: number[] | undefined;\n\n  /**\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\n   * hold focus until items appear within the zone.\n   */\n  _isParked: boolean = false;\n  _parkedTabIndex: string | null | undefined;\n\n  /** The child element with tabindex=0. */\n  _defaultFocusElement: HTMLElement | null;\n  _focusAlignment: Point;\n  _isInnerZone: boolean;\n\n  /** Used to allow us to move to next focusable element even when we're focusing on a input element when pressing tab */\n  _processingTabKey: boolean;\n\n  windowElement: Window | null;\n\n  constructor(props: FocusZoneProps) {\n    super(props);\n\n    this._id = _.uniqueId('FocusZone');\n\n    this._focusAlignment = {\n      left: 0,\n      top: 0,\n    };\n\n    this._processingTabKey = false;\n  }\n\n  componentDidMount(): void {\n    _allInstances[this._id] = this;\n\n    this.setRef(this); // called here to support functional components, we only need HTMLElement ref anyway\n\n    if (!this._root.current) {\n      return;\n    }\n\n    // @ts-ignore\n    this.windowElement = getWindow(this._root.current);\n    let parentElement = getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);\n    const doc = getDocument(this._root.current);\n\n    // @ts-ignore\n    while (parentElement && parentElement !== doc.body && parentElement.nodeType === 1) {\n      if (isElementFocusZone(parentElement)) {\n        this._isInnerZone = true;\n        break;\n      }\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    if (!this._isInnerZone) {\n      _outerZones.add(this);\n\n      if (this.windowElement && _outerZones.size === 1) {\n        this.windowElement.addEventListener('keydown', this._onKeyDownCapture, true);\n      }\n    }\n\n    this._root.current.addEventListener('blur', this._onBlur, true);\n\n    // Assign initial tab indexes so that we can set initial focus as appropriate.\n    this.updateTabIndexes();\n\n    if (this.props.shouldFocusOnMount) {\n      this.focus();\n    }\n  }\n\n  componentDidUpdate(): void {\n    if (!this._root.current) {\n      return;\n    }\n    const doc = getDocument(this._root.current);\n\n    if (\n      doc &&\n      this._lastIndexPath &&\n      (doc.activeElement === doc.body ||\n        doc.activeElement === null ||\n        (this.props.restoreFocusFromRoot && doc.activeElement === this._root.current))\n    ) {\n      // The element has been removed after the render, attempt to restore focus.\n      const elementToFocus = getFocusableByIndexPath(this._root.current as HTMLElement, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this.setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this.setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this.setParkedFocus(true);\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    delete _allInstances[this._id];\n\n    if (!this._isInnerZone) {\n      _outerZones.delete(this);\n\n      if (this.windowElement && _outerZones.size === 0) {\n        this.windowElement.removeEventListener('keydown', this._onKeyDownCapture, true);\n      }\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  }\n\n  render() {\n    const { className } = this.props;\n\n    const ElementType = getElementType(this.props);\n    const unhandledProps = getUnhandledProps(_.keys(FocusZone.propTypes) as any, this.props);\n\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this.evaluateFocusBeforeRender();\n\n    return (\n      <ElementType\n        {...unhandledProps}\n        className={cx(FocusZone.className, className)}\n        data-focuszone-id={this._id}\n        onKeyDown={this._onKeyDown}\n        onFocus={this._onFocus}\n        onMouseDownCapture={this._onMouseDown}\n      >\n        {this.props.children}\n      </ElementType>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focus(forceIntoFirstElement: boolean = false): boolean {\n    if (this._root.current) {\n      if (\n        !forceIntoFirstElement &&\n        this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        this._isInnerZone\n      ) {\n        const ownerZoneElement = this.getOwnerZone(this._root.current) as HTMLElement;\n\n        if (ownerZoneElement !== this._root.current) {\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      }\n      if (\n        !forceIntoFirstElement &&\n        this._activeElement &&\n        elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) &&\n        isElementTabbable(this._activeElement)\n      ) {\n        this._activeElement.focus();\n        return true;\n      }\n\n      const firstChild = this._root.current.firstChild as HTMLElement;\n\n      return this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement);\n    }\n    return false;\n  }\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusLast(): boolean {\n    if (this._root.current) {\n      const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * onBeforeFocus to created delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusElement(element: HTMLElement): boolean {\n    const { shouldReceiveFocus } = this.props;\n\n    if (shouldReceiveFocus && !shouldReceiveFocus(element)) {\n      return false;\n    }\n\n    if (element) {\n      this.setActiveElement(element);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  setRef = (elem: React.ReactInstance): void => {\n    // findDOMNode needed to get correct DOM ref with react-hot-loader, see https://github.com/gaearon/react-hot-loader/issues/964\n    this._root.current = ReactDOM.findDOMNode(elem) as HTMLElement;\n  };\n\n  // Record if focus was in the zone, what the index path to the element is at this time.\n  evaluateFocusBeforeRender(): void {\n    if (!this._root.current) {\n      return;\n    }\n    const doc = getDocument(this._root.current);\n\n    if (!doc) {\n      return;\n    }\n\n    const focusedElement = doc.activeElement as HTMLElement;\n\n    // Only update the index path if we are not parked on the root.\n    if (focusedElement !== this._root.current) {\n      const shouldRestoreFocus = elementContains(this._root.current, focusedElement, ALLOW_VIRTUAL_ELEMENTS);\n\n      this._lastIndexPath = shouldRestoreFocus\n        ? getElementIndexPath(this._root.current as HTMLElement, doc.activeElement as HTMLElement)\n        : undefined;\n    }\n  }\n\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  setParkedFocus(isParked: boolean): void {\n    if (this._root.current && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = this._root.current.getAttribute('tabindex');\n          this._root.current.setAttribute('tabindex', '-1');\n        }\n        this._root.current.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          this._root.current.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          this._root.current.removeAttribute('tabindex');\n        }\n      }\n    }\n  }\n\n  _onBlur = () => {\n    this.setParkedFocus(false);\n  };\n\n  _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    const {\n      onActiveElementChanged,\n      stopFocusPropagation,\n      shouldFocusInnerElementWhenReceivedFocus,\n      defaultTabbableElement,\n    } = this.props;\n\n    let newActiveElement: HTMLElement | undefined;\n    const isImmediateDescendant = this.isImmediateDescendantOfZone(ev.target as HTMLElement);\n\n    if (isImmediateDescendant) {\n      newActiveElement = ev.target as HTMLElement;\n    } else {\n      let parentElement = ev.target as HTMLElement;\n\n      while (parentElement && parentElement !== this._root.current) {\n        if (isElementTabbable(parentElement) && this.isImmediateDescendantOfZone(parentElement)) {\n          newActiveElement = parentElement;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n      }\n    }\n\n    // If an inner focusable element should be focused when FocusZone container receives focus\n    if (shouldFocusInnerElementWhenReceivedFocus && ev.target === this._root.current) {\n      const maybeElementToFocus = defaultTabbableElement && defaultTabbableElement(this._root.current);\n\n      // try to focus defaultTabbable element\n      if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n        newActiveElement = maybeElementToFocus;\n        maybeElementToFocus.focus();\n      } else {\n        // force focus on first focusable element\n        this.focus(true);\n        if (this._activeElement) {\n          // set to null as new active element was handled in method above\n          // @ts-ignore\n          newActiveElement = null;\n        }\n      }\n    }\n\n    if (newActiveElement && newActiveElement !== this._activeElement) {\n      this._activeElement = newActiveElement;\n\n      if (isImmediateDescendant) {\n        this.setFocusAlignment(this._activeElement);\n        this.updateTabIndexes();\n      }\n    }\n\n    if (onActiveElementChanged) {\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\n    }\n\n    if (stopFocusPropagation) {\n      ev.stopPropagation();\n    }\n\n    _.invoke(this.props, 'onFocus', ev);\n  };\n\n  /**\n   * Handle global tab presses so that we can patch tabindexes on the fly.\n   */\n  _onKeyDownCapture = (ev: KeyboardEvent) => {\n    if (keyboardKey.getCode(ev) === keyboardKey.Tab) {\n      _outerZones.forEach(zone => zone.updateTabIndexes());\n    }\n  };\n\n  _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { disabled } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    let target = ev.target as HTMLElement;\n    const path: HTMLElement[] = [];\n\n    while (target && target !== this._root.current) {\n      path.push(target);\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    }\n\n    while (path.length) {\n      target = path.pop() as HTMLElement;\n\n      if (target && isElementTabbable(target)) {\n        this.setActiveElement(target, true);\n      }\n\n      if (isElementFocusZone(target)) {\n        // Stop here since the focus zone will take care of its own children.\n        break;\n      }\n    }\n  };\n\n  setActiveElement(element: HTMLElement, forceAlignemnt?: boolean): void {\n    const previousActiveElement = this._activeElement;\n\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this.updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignemnt) {\n        this.setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  }\n\n  preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n\n  /**\n   * Handle the keystrokes.\n   */\n  _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\n    const { direction, disabled, shouldEnterInnerZone } = this.props;\n\n    if (disabled) {\n      return undefined;\n    }\n\n    const doc = getDocument(this._root.current);\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // @ts-ignore\n    if (doc.activeElement === this._root.current && this._isInnerZone) {\n      // If this element has focus, it is being controlled by a parent.\n      // Ignore the keystroke.\n      return undefined;\n    }\n\n    // If the default has been prevented, do not process keyboard events.\n    if (ev.isDefaultPrevented()) {\n      return undefined;\n    }\n\n    if (\n      shouldEnterInnerZone &&\n      shouldEnterInnerZone(ev) &&\n      this.isImmediateDescendantOfZone(ev.target as HTMLElement)\n    ) {\n      // Try to focus\n      const innerZone = this.getFirstInnerZone();\n\n      if (innerZone) {\n        if (!innerZone.focus(true)) {\n          return undefined;\n        }\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\n        if (\n          !this.focusElement(\n            getNextElement(\n              ev.target as HTMLElement,\n              (ev.target as HTMLElement).firstChild as HTMLElement,\n              true,\n            ) as HTMLElement,\n          )\n        ) {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    } else if (ev.altKey) {\n      return undefined;\n    } else {\n      switch (keyboardKey.getCode(ev)) {\n        case keyboardKey.Spacebar:\n          // @ts-ignore\n          if (this.tryInvokeClickForFocusable(ev.target as HTMLElement)) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.ArrowLeft:\n          if (direction !== FocusZoneDirection.vertical) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusLeft()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowRight:\n          if (direction !== FocusZoneDirection.vertical) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusRight()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowUp:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusUp()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowDown:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusDown()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.Tab:\n          if (\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n              this.isElementInput(ev.target as HTMLElement))\n          ) {\n            let focusChanged = false;\n            this._processingTabKey = true;\n            if (direction === FocusZoneDirection.vertical) {\n              focusChanged = ev.shiftKey ? this.moveFocusUp() : this.moveFocusDown();\n            } else if (direction === FocusZoneDirection.horizontal || direction === FocusZoneDirection.bidirectional) {\n              const tabWithDirection = this.props.isRtl ? !ev.shiftKey : ev.shiftKey;\n              focusChanged = tabWithDirection ? this.moveFocusLeft() : this.moveFocusRight();\n            }\n            this._processingTabKey = false;\n            if (focusChanged) {\n              break;\n            }\n          } else if (this.props.shouldResetActiveElementWhenTabFromZone) {\n            this._activeElement = null;\n          }\n          return undefined;\n\n        case keyboardKey.Home:\n          if (\n            this.isContentEditableElement(ev.target as HTMLElement) ||\n            (this.isElementInput(ev.target as HTMLElement) &&\n              !this.shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            firstChild &&\n            this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.End:\n          if (\n            this.isContentEditableElement(ev.target as HTMLElement) ||\n            (this.isElementInput(ev.target as HTMLElement) &&\n              !this.shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.Enter:\n          // @ts-ignore\n          if (this.tryInvokeClickForFocusable(ev.target as HTMLElement)) {\n            break;\n          }\n          return undefined;\n\n        default:\n          return undefined;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n\n    return undefined;\n  };\n\n  /**\n   * Walk up the dom try to find a focusable element.\n   * TODO\n   */\n  tryInvokeClickForFocusable(): boolean {\n    return false;\n  }\n\n  /**\n   * Traverse to find first child zone.\n   */\n  getFirstInnerZone(forRootElement?: HTMLElement | null): FocusZone | null {\n    const rootElement = forRootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n    }\n\n    let child = rootElement.firstElementChild as HTMLElement | null;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n      }\n      const match = this.getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling as HTMLElement | null;\n    }\n\n    return null;\n  }\n\n  moveFocus(\n    isForward: boolean,\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\n    // @ts-ignore\n    ev?: Event,\n    useDefaultWrap: boolean = true,\n  ): boolean {\n    let element = this._activeElement;\n    let candidateDistance = -1;\n    let candidateElement: HTMLElement | undefined = undefined;\n    let changedFocus = false;\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this.isElementInput(element)) {\n      if (!this.shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = (isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element)) as HTMLElement;\n\n      if (isBidirectional) {\n        if (element) {\n          const targetRect = element.getBoundingClientRect();\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n\n    return changedFocus;\n  }\n\n  moveFocusDown(): boolean {\n    let targetTop = -1;\n    const leftAlignment = this._focusAlignment.left;\n\n    if (\n      this.moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n\n        if (targetRectTop < activeRectBottom) {\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusUp(): boolean {\n    let targetTop = -1;\n    const leftAlignment = this._focusAlignment.left;\n\n    if (\n      this.moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectTop = Math.floor(activeRect.top);\n\n        if (targetRectBottom > activeRectTop) {\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusLeft(): boolean {\n    if (\n      this.moveFocus(\n        // @ts-ignore\n        this.props.isRtl,\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (this.props.isRtl) {\n            // When in RTL, this comparison should be the same as the one in moveFocusRight for LTR.\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n            // This is important, because we want to be comparing the top of the target rect\n            // with the bottom of the active rect.\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.right <= activeRect.right &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = activeRect.right - targetRect.right;\n          }\n\n          return distance;\n        },\n        undefined /* ev */,\n        true,\n      )\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusRight(): boolean {\n    if (\n      this.moveFocus(\n        !this.props.isRtl,\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (this.props.isRtl) {\n            // When in RTL, this comparison should be the same as the one in moveFocusLeft for LTR.\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n            // This is important, because we want to be comparing the bottom of the target rect\n            // with the top of the active rect.\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.left >= activeRect.left &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = targetRect.left - activeRect.left;\n          }\n\n          return distance;\n        },\n        undefined /* ev */,\n        true,\n      )\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean) {\n    if (\n      this.props.direction === FocusZoneDirection.bidirectional &&\n      (!this._focusAlignment || isHorizontal || isVertical)\n    ) {\n      const rect = element.getBoundingClientRect();\n      const left = rect.left + rect.width / 2;\n      const top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = { left, top };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  }\n\n  isImmediateDescendantOfZone(element?: HTMLElement): boolean {\n    return this.getOwnerZone(element) === this._root.current;\n  }\n\n  getOwnerZone(element?: HTMLElement): HTMLElement | null {\n    const doc = getDocument(this._root.current);\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\n\n    // @ts-ignore\n    while (parentElement && parentElement !== this._root.current && parentElement !== doc.body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return this._root.current;\n  }\n\n  updateTabIndexes(onElement?: HTMLElement) {\n    let element = onElement;\n\n    if (!this._activeElement && this.props.defaultTabbableElement) {\n      // @ts-ignore\n      this._activeElement = this.props.defaultTabbableElement(this._root.current);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) {\n        this._activeElement = null;\n      }\n    }\n\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    const childNodes = element && element.children;\n\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      const child = childNodes[childIndex] as HTMLElement;\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (\n            !this._isInnerZone &&\n            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n          ) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (\n          !this._isInnerZone &&\n          ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n        ) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this.updateTabIndexes(child);\n    }\n  }\n\n  isContentEditableElement(element: HTMLElement): boolean {\n    return element && element.getAttribute('contenteditable') === 'true';\n  }\n\n  isElementInput(element: HTMLElement): boolean {\n    if (\n      element &&\n      element.tagName &&\n      (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  shouldInputLoseFocus(element: HTMLInputElement, isForward?: boolean) {\n    // If a tab was used, we want to focus on the next element.\n    if (\n      !this._processingTabKey &&\n      element &&\n      element.type &&\n      ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1\n    ) {\n      const selectionStart = element.selectionStart;\n      const selectionEnd = element.selectionEnd;\n      const isRangeSelected = selectionStart !== selectionEnd;\n      const inputValue = element.value;\n\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward.\n      // 3. when selection start is not the end of length and it is forward.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)\n      // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the\n      // callback shouldInputLoseFocusOnArrowKey\n      if (\n        isRangeSelected ||\n        (selectionStart! > 0 && !isForward) ||\n        (selectionStart !== inputValue.length && isForward) ||\n        (!!this.props.handleTabKey &&\n          !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"],"file":"FocusZone.js"}