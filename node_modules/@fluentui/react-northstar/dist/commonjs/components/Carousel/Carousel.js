"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var _accessibility = require("@fluentui/accessibility");

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactComponentRef = require("@fluentui/react-component-ref");

var _Animation = _interopRequireDefault(require("../Animation/Animation"));

var _utils = require("../../utils");

var _types = require("../../types");

var _CarouselItem = _interopRequireDefault(require("./CarouselItem"));

var _Text = _interopRequireDefault(require("../Text/Text"));

var _CarouselNavigation = _interopRequireDefault(require("./CarouselNavigation"));

var _CarouselNavigationItem = _interopRequireDefault(require("./CarouselNavigationItem"));

var _CarouselPaddle = _interopRequireDefault(require("./CarouselPaddle"));

var Carousel =
/*#__PURE__*/
function (_AutoControlledCompon) {
  (0, _inherits2.default)(Carousel, _AutoControlledCompon);

  function Carousel() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, Carousel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Carousel)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "actionHandlers", {
      showNextSlideByKeyboardNavigation: function showNextSlideByKeyboardNavigation(e) {
        e.preventDefault();

        _this.showNextSlide(e, true);
      },
      showPreviousSlideByKeyboardNavigation: function showPreviousSlideByKeyboardNavigation(e) {
        e.preventDefault();

        _this.showPreviousSlide(e, true);
      },
      showNextSlideByPaddlePress: function showNextSlideByPaddlePress(e) {
        e.preventDefault();

        _this.showNextSlide(e, false);

        _this.handleNextPaddleFocus();
      },
      showPreviousSlideByPaddlePress: function showPreviousSlideByPaddlePress(e) {
        e.preventDefault();

        _this.showPreviousSlide(e, false);

        _this.handlePreviousPaddleFocus();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "itemRefs", []);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "paddleNextRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "paddlePreviousRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focusItemAtIndex", (0, _debounce2.default)(function (index) {
      _this.itemRefs[index].current.focus();
    }, 400));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "overrideItemProps", function (predefinedProps) {
      return {
        onFocus: function onFocus(e, itemProps) {
          _this.setState({
            shouldFocusContainer: e.currentTarget === e.target,
            isFromKeyboard: (0, _utils.isFromKeyboard)()
          });

          (0, _invoke2.default)(predefinedProps, 'onFocus', e, itemProps);
        },
        onBlur: function onBlur(e, itemProps) {
          _this.setState({
            shouldFocusContainer: e.currentTarget.contains(e.relatedTarget),
            isFromKeyboard: false
          });

          (0, _invoke2.default)(predefinedProps, 'onBlur', e, itemProps);
        }
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderContent", function (accessibility, classes, unhandledProps) {
      var _this$props = _this.props,
          getItemPositionText = _this$props.getItemPositionText,
          items = _this$props.items,
          circular = _this$props.circular;
      var _this$state = _this.state,
          activeIndex = _this$state.activeIndex,
          itemIds = _this$state.itemIds,
          prevActiveIndex = _this$state.prevActiveIndex;
      _this.itemRefs = [];
      return React.createElement("div", (0, _extends2.default)({
        className: classes.itemsContainerWrapper
      }, accessibility.attributes.itemsContainerWrapper), React.createElement("div", (0, _extends2.default)({
        className: (0, _classnames.default)(Carousel.slotClassNames.itemsContainer, classes.itemsContainer)
      }, accessibility.attributes.itemsContainer, (0, _utils.applyAccessibilityKeyHandlers)(accessibility.keyHandlers.itemsContainer, unhandledProps)), items && items.map(function (item, index) {
        var itemRef = React.createRef();

        _this.itemRefs.push(itemRef);

        var active = activeIndex === index;
        var slideToNext = prevActiveIndex < activeIndex;
        var initialMounting = prevActiveIndex === -1;

        if (circular && prevActiveIndex === items.length - 1 && activeIndex === 0) {
          slideToNext = true;
        } else if (circular && prevActiveIndex === 0 && activeIndex === items.length - 1) {
          slideToNext = false;
        }

        return React.createElement(_Animation.default, {
          key: item['key'] || index,
          mountOnEnter: true,
          unmountOnExit: true,
          visible: active,
          name: initialMounting ? '' : active ? slideToNext ? 'carousel-slide-to-next-enter' : 'carousel-slide-to-previous-enter' : slideToNext ? 'carousel-slide-to-next-exit' : 'carousel-slide-to-previous-exit'
        }, React.createElement(_reactComponentRef.Ref, {
          innerRef: itemRef
        }, _CarouselItem.default.create(item, {
          defaultProps: function defaultProps() {
            return Object.assign({
              active: active,
              id: itemIds[index],
              navigation: !!_this.props.navigation
            }, getItemPositionText && {
              itemPositionText: getItemPositionText(index, items.length)
            });
          },
          overrideProps: _this.overrideItemProps
        })));
      })));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleNextPaddleFocus", function () {
      // if 'next' paddle will disappear, will focus 'previous' one.
      if (!_this.props.navigation && _this.state.activeIndex >= _this.props.items.length - 2 && !_this.props.circular) {
        _this.paddlePreviousRef.current.focus();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handlePreviousPaddleFocus", function () {
      // if 'previous' paddle will disappear, will focus 'next' one.
      if (!_this.props.navigation && _this.state.activeIndex <= 1 && !_this.props.circular) {
        _this.paddleNextRef.current.focus();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "showPreviousSlide", function (e, focusItem) {
      _this.setActiveIndex(e, _this.state.activeIndex - 1, focusItem);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "showNextSlide", function (e, focusItem) {
      _this.setActiveIndex(e, _this.state.activeIndex + 1, focusItem);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handlePaddleOverrides", function (predefinedProps, paddleName) {
      return {
        onClick: function onClick(e, paddleProps) {
          (0, _invoke2.default)(predefinedProps, 'onClick', e, paddleProps);

          if (paddleName === 'paddleNext') {
            _this.showNextSlide(e, false);

            _this.handleNextPaddleFocus();
          } else if (paddleName === 'paddlePrevious') {
            _this.showPreviousSlide(e, false);

            _this.handlePreviousPaddleFocus();
          }
        },
        onBlur: function onBlur(e, paddleProps) {
          if (e.relatedTarget !== _this.paddleNextRef.current) {
            _this.setState({
              ariaLiveOn: false
            });
          }
        },
        onFocus: function onFocus(e, paddleProps) {
          (0, _invoke2.default)(predefinedProps, 'onFocus', e, paddleProps);

          _this.setState({
            ariaLiveOn: true
          });
        }
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderPaddles", function (accessibility) {
      var _this$props2 = _this.props,
          paddlePrevious = _this$props2.paddlePrevious,
          paddleNext = _this$props2.paddleNext,
          items = _this$props2.items,
          circular = _this$props2.circular;
      var activeIndex = _this.state.activeIndex;
      return React.createElement(React.Fragment, null, React.createElement(_reactComponentRef.Ref, {
        innerRef: _this.paddlePreviousRef
      }, _CarouselPaddle.default.create(paddlePrevious, {
        defaultProps: function defaultProps() {
          return Object.assign({
            className: Carousel.slotClassNames.paddlePrevious,
            previous: true,
            hidden: items !== undefined && !circular && activeIndex === 0
          }, accessibility.attributes.paddlePrevious, {}, (0, _utils.applyAccessibilityKeyHandlers)(accessibility.keyHandlers.paddlePrevious, paddlePrevious));
        },
        overrideProps: function overrideProps(predefinedProps) {
          return _this.handlePaddleOverrides(predefinedProps, 'paddlePrevious');
        }
      })), React.createElement(_reactComponentRef.Ref, {
        innerRef: _this.paddleNextRef
      }, _CarouselPaddle.default.create(paddleNext, {
        defaultProps: function defaultProps() {
          return Object.assign({
            className: Carousel.slotClassNames.paddleNext,
            next: true,
            hidden: items !== undefined && !circular && activeIndex === items.length - 1
          }, accessibility.attributes.paddleNext, {}, (0, _utils.applyAccessibilityKeyHandlers)(accessibility.keyHandlers.paddleNext, paddleNext));
        },
        overrideProps: function overrideProps(predefinedProps) {
          return _this.handlePaddleOverrides(predefinedProps, 'paddleNext');
        }
      })));
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderNavigation", function () {
      var _this$props3 = _this.props,
          getItemPositionText = _this$props3.getItemPositionText,
          navigation = _this$props3.navigation,
          items = _this$props3.items;

      if (!items || !items.length) {
        return null;
      }

      var activeIndex = _this.state.activeIndex;
      return navigation ? _CarouselNavigation.default.create(navigation, {
        defaultProps: function defaultProps() {
          return {
            className: Carousel.slotClassNames.navigation,
            iconOnly: true,
            activeIndex: activeIndex
          };
        },
        overrideProps: function overrideProps(predefinedProps) {
          return {
            onItemClick: function onItemClick(e, itemProps) {
              var index = itemProps.index;

              _this.setActiveIndex(e, index, true);

              (0, _invoke2.default)(predefinedProps, 'onClick', e, itemProps);
            }
          };
        }
      }) : React.createElement(_Text.default, {
        "aria-hidden": "true",
        className: Carousel.slotClassNames.pagination,
        content: getItemPositionText(activeIndex, items.length)
      });
    });
    return _this;
  }

  (0, _createClass2.default)(Carousel, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.focusItemAtIndex.cancel();
    }
  }, {
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState() {
      return {
        activeIndex: 0,
        prevActiveIndex: -1,
        ariaLiveOn: false,
        itemIds: [],
        shouldFocusContainer: false,
        isFromKeyboard: false
      };
    }
  }, {
    key: "setActiveIndex",
    value: function setActiveIndex(e, index, focusItem) {
      var _this$props4 = this.props,
          circular = _this$props4.circular,
          items = _this$props4.items;
      var lastItemIndex = items.length - 1;
      var activeIndex = index;

      if (index < 0) {
        if (!circular) {
          return;
        }

        activeIndex = lastItemIndex;
      }

      if (index > lastItemIndex) {
        if (!circular) {
          return;
        }

        activeIndex = 0;
      }

      this.setState({
        prevActiveIndex: this.state.activeIndex,
        activeIndex: activeIndex
      });
      (0, _invoke2.default)(this.props, 'onActiveIndexChange', e, this.props);

      if (focusItem) {
        this.focusItemAtIndex(activeIndex);
      }
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref) {
      var ElementType = _ref.ElementType,
          classes = _ref.classes,
          accessibility = _ref.accessibility,
          unhandledProps = _ref.unhandledProps;
      var children = this.props.children;
      return React.createElement(ElementType, (0, _extends2.default)({
        className: classes.root
      }, accessibility.attributes.root, unhandledProps, (0, _utils.applyAccessibilityKeyHandlers)(accessibility.keyHandlers.root, unhandledProps)), (0, _utils.childrenExist)(children) ? children : React.createElement(React.Fragment, null, this.renderContent(accessibility, classes, unhandledProps), this.renderPaddles(accessibility), this.renderNavigation()));
    }
  }], [{
    key: "getAutoControlledStateFromProps",
    value: function getAutoControlledStateFromProps(props, state) {
      var items = props.items;
      var itemIds = state.itemIds;

      if (!items) {
        return null;
      }

      return {
        itemIds: items.map(function (item, index) {
          return (0, _utils.getOrGenerateIdFromShorthand)('carousel-item-', item, itemIds[index]);
        })
      };
    }
  }]);
  return Carousel;
}(_utils.AutoControlledComponent);

(0, _defineProperty2.default)(Carousel, "create", void 0);
(0, _defineProperty2.default)(Carousel, "displayName", 'Carousel');
(0, _defineProperty2.default)(Carousel, "className", 'ui-carousel');
(0, _defineProperty2.default)(Carousel, "slotClassNames", {
  itemsContainer: "".concat(Carousel.className, "__itemscontainer"),
  paddleNext: "".concat(Carousel.className, "__paddlenext"),
  paddlePrevious: "".concat(Carousel.className, "__paddleprevious"),
  pagination: "".concat(Carousel.className, "__pagination"),
  navigation: "".concat(Carousel.className, "__navigation")
});
(0, _defineProperty2.default)(Carousel, "propTypes", Object.assign({}, _utils.commonPropTypes.createCommon({
  content: false
}), {
  activeIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  ariaRoleDescription: PropTypes.string,
  ariaLabel: PropTypes.string,
  circular: PropTypes.bool,
  defaultActiveIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  getItemPositionText: PropTypes.func,
  items: customPropTypes.collectionShorthand,
  navigation: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  navigationPosition: PropTypes.string,
  onActiveIndexChange: PropTypes.func,
  paddleNext: customPropTypes.itemShorthand,
  paddlesPosition: PropTypes.string,
  paddlePrevious: customPropTypes.itemShorthand
}));
(0, _defineProperty2.default)(Carousel, "autoControlledProps", ['activeIndex']);
(0, _defineProperty2.default)(Carousel, "defaultProps", {
  accessibility: _accessibility.carouselBehavior,
  paddlePrevious: {},
  paddleNext: {}
});
(0, _defineProperty2.default)(Carousel, "Item", _CarouselItem.default);
(0, _defineProperty2.default)(Carousel, "Navigation", _CarouselNavigation.default);
(0, _defineProperty2.default)(Carousel, "NavigationItem", _CarouselNavigationItem.default);
(0, _defineProperty2.default)(Carousel, "Paddle", _CarouselPaddle.default);
Carousel.create = (0, _utils.createShorthandFactory)({
  Component: Carousel,
  mappedArrayProp: 'items'
});
/**
 * A Carousel displays data organised as a gallery.
 *
 * @accessibility
 * Implements [ARIA Carousel](https://www.w3.org/WAI/tutorials/carousels/structure/) design pattern.
 * @accessibilityIssues
 * [VoiceOver doens't narrate label referenced by aria-labelledby attribute, when role is "tabpanel"](https://bugs.chromium.org/p/chromium/issues/detail?id=1040924)
 */

var _default = (0, _types.withSafeTypeForAs)(Carousel);

exports.default = _default;
//# sourceMappingURL=Carousel.js.map
