{"version":3,"sources":["components/Toolbar/Toolbar.tsx"],"names":["WAS_FOCUSABLE_ATTRIBUTE","Toolbar","React","createRef","$overflowContainer","overflowContainerRef","current","$overflowItem","overflowItemRef","$offsetMeasure","offsetMeasureRef","rtl","scrollTo","Number","MAX_SAFE_INTEGER","$items","children","overflowContainerBoundingRect","getBoundingClientRect","overflowItemBoundingRect","offsetMeasureBoundingRect","absolutePositioningOffset","horizontal","right","left","vertical","top","isOverflowing","$lastVisibleItem","lastVisibleItemRect","$item","i","itemBoundingRect","isItemOverflowing","hide","wouldItemCollide","lastVisibleItemIndex","show","props","overflowOpen","style","position","setOverflowPosition","items","length","getOverflowItems","slice","end","e","hideOverflowItems","item","kind","ToolbarDivider","create","ToolbarRadioGroup","ToolbarItem","defaultProps","accessibility","toggleButtonBehavior","ToolbarCustomItem","el","visibility","context","target","activeElement","contains","containerRef","firstFocusableItem","firstElementChild","focus","wasFocusable","getAttribute","IS_FOCUSABLE_ATTRIBUTE","setAttribute","removeAttribute","containerBoundingRect","actualWindow","defaultView","wouldCollide","itemLeftMargin","parseFloat","getComputedStyle","marginLeft","width","itemRightMargin","marginRight","lastVisibleItemMarginLeft","lastVisibleItemRightMargin","afterComponentRendered","animationFrameId","undefined","cancelAnimationFrame","requestAnimationFrame","overflowItem","icon","outline","overrideProps","menu","menuOpen","onMenuOpenChange","ElementType","classes","styles","unhandledProps","overflow","variables","root","attributes","renderItems","overflowContainer","getVisibleItems","renderOverflowItem","offsetMeasure","handleWindowResize","UIComponent","commonPropTypes","createCommon","customPropTypes","collectionShorthandWithKindProp","PropTypes","bool","shorthandAllowingChildren","onOverflow","func","onOverflowOpenChange","toolbarBehavior","ToolbarMenu","ToolbarMenuDivider","ToolbarMenuItem","ToolbarMenuRadioGroup","Component","mappedProp"],"mappings":"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","sourcesContent":["import { Accessibility, toolbarBehavior, toggleButtonBehavior, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport * as React from 'react';\nimport * as _ from 'lodash';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as PropTypes from 'prop-types';\nimport { Ref } from '@fluentui/react-component-ref';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { getFirstFocusable } from '@fluentui/react-bindings';\n\nimport {\n  childrenExist,\n  createShorthandFactory,\n  UIComponent,\n  UIComponentProps,\n  ContentComponentProps,\n  ChildrenComponentProps,\n  commonPropTypes,\n  ColorComponentProps,\n  ShorthandFactory,\n} from '../../utils';\n\nimport { ComponentEventHandler, ShorthandCollection, ShorthandValue, WithAsProp, withSafeTypeForAs } from '../../types';\n\nimport ToolbarCustomItem from './ToolbarCustomItem';\nimport ToolbarDivider from './ToolbarDivider';\nimport ToolbarItem, { ToolbarItemProps } from './ToolbarItem';\nimport ToolbarMenu from './ToolbarMenu';\nimport ToolbarMenuDivider from './ToolbarMenuDivider';\nimport ToolbarMenuItem, { ToolbarMenuItemProps } from './ToolbarMenuItem';\nimport ToolbarMenuRadioGroup from './ToolbarMenuRadioGroup';\nimport ToolbarRadioGroup from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\n\nexport type ToolbarItemShorthandKinds = 'divider' | 'item' | 'group' | 'toggle' | 'custom';\n\ntype PositionOffset = {\n  vertical: number;\n  horizontal: number;\n};\n\nconst WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\n\nexport interface ToolbarProps\n  extends UIComponentProps,\n    ContentComponentProps,\n    ChildrenComponentProps,\n    ColorComponentProps {\n  /** Accessibility behavior if overridden by the user. */\n  accessibility?: Accessibility;\n\n  /** Shorthand array of props for Toolbar. */\n  items?: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>;\n\n  /**\n   *  Automatically move overflow items to overflow menu.\n   *  For automatic overflow to work correctly, toolbar items including overflowMenuItem\n   *  must NOT change their size! If you need to change item's size, rerender the Toolbar.\n   */\n  overflow?: boolean;\n\n  /** Indicates if the overflow menu is open. Only valid if `overflow` is enabled and regular items do not fit. */\n  overflowOpen?: boolean;\n\n  /**\n   * Shorthand for the overflow item which is displayed when `overflow` is enabled and regular toolbar items do not fit.\n   * Do not set any menu on this item, Toolbar overrides it.\n   */\n  overflowItem?: ShorthandValue<ToolbarItemProps>;\n\n  /**\n   * Called when overflow is recomputed (after render, update or window resize). Even if all items fit.\n   * @param itemsVisible - number of items visible\n   */\n  onOverflow?: (itemsVisible: number) => void;\n\n  /**\n   * Event for request to change 'overflowOpen' value.\n   * @param event - React's original SyntheticEvent.\n   * @param data - All props and proposed value.\n   */\n  onOverflowOpenChange?: ComponentEventHandler<ToolbarProps>;\n\n  /**\n   * Callback to get items to be rendered in overflow menu.\n   * Called when overflow menu is rendered opened.\n   * @param startIndex - Index of the first item to be displayed in the overflow menu (the first item which does not fit the toolbar).\n   */\n  getOverflowItems?: (startIndex: number) => ShorthandCollection<ToolbarMenuItemProps, ToolbarItemShorthandKinds>; // FIXME: use correct kind\n}\n\nclass Toolbar extends UIComponent<WithAsProp<ToolbarProps>> {\n  static create: ShorthandFactory<ToolbarProps>;\n\n  static className = 'ui-toolbar';\n\n  static displayName = 'Toolbar';\n\n  static propTypes = {\n    ...commonPropTypes.createCommon(),\n    items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n    overflow: PropTypes.bool,\n    overflowOpen: PropTypes.bool,\n    overflowItem: customPropTypes.shorthandAllowingChildren,\n    onOverflow: PropTypes.func,\n    onOverflowOpenChange: PropTypes.func,\n    getOverflowItems: PropTypes.func,\n  };\n\n  static defaultProps = {\n    accessibility: toolbarBehavior,\n    items: [],\n    overflowItem: {},\n  };\n\n  static CustomItem = ToolbarCustomItem;\n  static Divider = ToolbarDivider;\n  static Item = ToolbarItem;\n  static Menu = ToolbarMenu;\n  static MenuDivider = ToolbarMenuDivider;\n  static MenuItem = ToolbarMenuItem;\n  static MenuRadioGroup = ToolbarMenuRadioGroup;\n  static RadioGroup = ToolbarRadioGroup;\n\n  overflowContainerRef = React.createRef<HTMLDivElement>();\n  overflowItemRef = React.createRef<HTMLElement>();\n  offsetMeasureRef = React.createRef<HTMLDivElement>();\n  containerRef = React.createRef<HTMLElement>();\n\n  // index of the last visible item in Toolbar, the rest goes to overflow menu\n  lastVisibleItemIndex: number;\n\n  animationFrameId: number;\n  rtl: boolean;\n\n  renderItems(items: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>) {\n    return _.map(items, (item: ShorthandValue<ToolbarItemProps & { kind?: ToolbarItemShorthandKinds }>) => {\n      const kind = _.get(item, 'kind', 'item');\n\n      switch (kind) {\n        case 'divider':\n          return ToolbarDivider.create(item);\n        case 'group':\n          return ToolbarRadioGroup.create(item);\n        case 'toggle':\n          return ToolbarItem.create(item, {\n            defaultProps: () => ({ accessibility: toggleButtonBehavior }),\n          });\n        case 'custom':\n          return ToolbarCustomItem.create(item);\n        default:\n          return ToolbarItem.create(item);\n      }\n    });\n  }\n\n  hide(el: HTMLElement) {\n    if (el.style.visibility === 'hidden') {\n      return;\n    }\n\n    if (this.context.target.activeElement === el || el.contains(this.context.target.activeElement)) {\n      if (this.containerRef.current) {\n        const firstFocusableItem = getFirstFocusable(\n          this.containerRef.current,\n          this.containerRef.current.firstElementChild as HTMLElement,\n        );\n\n        if (firstFocusableItem) {\n          firstFocusableItem.focus();\n        }\n      }\n    }\n\n    el.style.visibility = 'hidden';\n    const wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n    }\n    el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n  }\n\n  show(el: HTMLElement) {\n    if (el.style.visibility !== 'hidden') {\n      return false;\n    }\n\n    el.style.visibility = null;\n    const wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    } else {\n      el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks if `item` overflows a `container`.\n   * TODO: check and fix all margin combination\n   */\n  isItemOverflowing(itemBoundingRect: ClientRect, containerBoundingRect: ClientRect) {\n    return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n  }\n\n  /**\n   * Checks if `item` would collide with eventual position of `overflowItem`.\n   */\n  wouldItemCollide(\n    $item: Element,\n    itemBoundingRect: ClientRect,\n    overflowItemBoundingRect: ClientRect,\n    containerBoundingRect: ClientRect,\n  ) {\n    const actualWindow: Window = this.context.target.defaultView;\n    let wouldCollide;\n\n    if (this.rtl) {\n      const itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n      wouldCollide =\n        itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left;\n\n      // console.log('Collision [RTL]', {\n      //   wouldCollide,\n      //   'itemBoundingRect.left': itemBoundingRect.left,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin: itemLeftMargin,\n      //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n      //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n      // })\n    } else {\n      const itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n      wouldCollide =\n        itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right;\n\n      // console.log('Collision', {\n      //   wouldCollide,\n      //   'itemBoundingRect.right': itemBoundingRect.right,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin,\n      //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n      //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n      // })\n    }\n\n    return wouldCollide;\n  }\n\n  /**\n   * Positions overflowItem next to lastVisible item\n   * TODO: consider overflowItem margin\n   */\n  setOverflowPosition(\n    $overflowItem: HTMLElement,\n    $lastVisibleItem: HTMLElement | undefined,\n    lastVisibleItemRect: ClientRect | undefined,\n    containerBoundingRect: ClientRect,\n    absolutePositioningOffset: PositionOffset,\n  ) {\n    const actualWindow: Window = this.context.target.defaultView;\n\n    if ($lastVisibleItem) {\n      if (this.rtl) {\n        const lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n\n        $overflowItem.style.right = `${containerBoundingRect.right -\n          lastVisibleItemRect.left +\n          lastVisibleItemMarginLeft +\n          absolutePositioningOffset.horizontal}px`;\n      } else {\n        const lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n\n        $overflowItem.style.left = `${lastVisibleItemRect.right -\n          containerBoundingRect.left +\n          lastVisibleItemRightMargin +\n          absolutePositioningOffset.horizontal}px`;\n      }\n    } else {\n      // there is no last visible item -> position the overflow as the first item\n      this.lastVisibleItemIndex = -1;\n      if (this.rtl) {\n        $overflowItem.style.right = `${absolutePositioningOffset.horizontal}px`;\n      } else {\n        $overflowItem.style.left = `${absolutePositioningOffset.horizontal}px`;\n      }\n    }\n  }\n\n  hideOverflowItems = () => {\n    const $overflowContainer = this.overflowContainerRef.current;\n    const $overflowItem = this.overflowItemRef.current;\n    const $offsetMeasure = this.offsetMeasureRef.current;\n    if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n      return;\n    }\n\n    // workaround: when resizing window with popup opened the container contents scroll for some reason\n    if (this.rtl) {\n      $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n    } else {\n      $overflowContainer.scrollTo(0, 0);\n    }\n\n    const $items = $overflowContainer.children;\n\n    const overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n    const overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n    const offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect();\n\n    // Absolute positioning offset\n    // Overflow menu is absolutely positioned relative to root slot\n    // If there is padding set on the root slot boundingClientRect computations use inner content box,\n    // but absolute position is relative to root slot's PADDING box.\n    // We compute absolute positioning offset\n    // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n    // TODO: replace by getComputedStyle('padding')\n    const absolutePositioningOffset: PositionOffset = {\n      horizontal: this.rtl\n        ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right\n        : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n      vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top,\n    };\n\n    let isOverflowing = false;\n    let $lastVisibleItem;\n    let lastVisibleItemRect;\n\n    // check all items from the last one back\n    _.forEachRight($items, ($item: HTMLElement, i: number) => {\n      if ($item === $overflowItem) {\n        return true;\n      }\n\n      const itemBoundingRect = $item.getBoundingClientRect();\n\n      // if the item is out of the crop rectangle, hide it\n      if (this.isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n        isOverflowing = true;\n        // console.log('Overflow', i, {\n        //   item: [itemBoundingRect.left, itemBoundingRect.right],\n        //   crop: [\n        //     overflowContainerBoundingRect.left,\n        //     overflowContainerBoundingRect.right,\n        //     overflowContainerBoundingRect.width,\n        //   ],\n        //   container: $overflowContainer,\n        // })\n        this.hide($item);\n        return true;\n      }\n\n      // if there is an overflow, check collision of remaining items with eventual overflow position\n      if (\n        isOverflowing &&\n        !$lastVisibleItem &&\n        this.wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)\n      ) {\n        this.hide($item);\n        return true;\n      }\n\n      // Remember the last visible item\n      if (!$lastVisibleItem) {\n        $lastVisibleItem = $item;\n        lastVisibleItemRect = itemBoundingRect;\n        this.lastVisibleItemIndex = i;\n      }\n\n      return this.show($item); // exit the loop when first visible item is found\n    });\n\n    // if there is an overflow,  position and show overflow item, otherwise hide it\n    if (isOverflowing || this.props.overflowOpen) {\n      $overflowItem.style.position = 'absolute';\n      this.setOverflowPosition(\n        $overflowItem,\n        $lastVisibleItem,\n        lastVisibleItemRect,\n        overflowContainerBoundingRect,\n        absolutePositioningOffset,\n      );\n      this.show($overflowItem);\n    } else {\n      this.lastVisibleItemIndex = this.props.items.length - 1;\n      this.hide($overflowItem);\n    }\n\n    _.invoke(this.props, 'onOverflow', this.lastVisibleItemIndex + 1);\n  };\n\n  getOverflowItems = () => {\n    // console.log('getOverflowItems()', this.props.items.slice(this.lastVisibleItemIndex + 1))\n    return this.props.getOverflowItems\n      ? this.props.getOverflowItems(this.lastVisibleItemIndex + 1)\n      : this.props.items.slice(this.lastVisibleItemIndex + 1);\n  };\n\n  getVisibleItems = () => {\n    // console.log('allItems()', this.props.items)\n    const end = this.props.overflowOpen ? this.lastVisibleItemIndex + 1 : this.props.items.length;\n    // console.log('getVisibleItems()', this.props.items.slice(0, end))\n    return this.props.items.slice(0, end);\n  };\n\n  componentDidMount() {\n    this.afterComponentRendered();\n  }\n\n  componentDidUpdate() {\n    this.afterComponentRendered();\n  }\n\n  componentWillUnmount() {\n    if (this.animationFrameId !== undefined) {\n      this.context.target.defaultView.cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = undefined;\n    }\n  }\n\n  afterComponentRendered() {\n    const actualWindow: Window = this.context.target.defaultView;\n\n    if (this.animationFrameId !== undefined) {\n      actualWindow.cancelAnimationFrame(this.animationFrameId);\n    }\n\n    // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n    this.animationFrameId = actualWindow.requestAnimationFrame(() => {\n      this.hideOverflowItems();\n    });\n  }\n\n  handleWindowResize = _.debounce((e: UIEvent) => {\n    this.hideOverflowItems();\n\n    if (this.props.overflowOpen) {\n      _.invoke(this.props, 'onOverflowOpenChange', e, {\n        ...this.props,\n        overflowOpen: false,\n      });\n    }\n  }, 16);\n\n  renderOverflowItem(overflowItem) {\n    return (\n      <Ref innerRef={this.overflowItemRef}>\n        {ToolbarItem.create(overflowItem, {\n          defaultProps: () => ({\n            // TODO: ups\n            icon: <MoreIcon {...{ outline: true }} />,\n          }),\n          overrideProps: {\n            menu: this.props.overflowOpen ? this.getOverflowItems() : [],\n            menuOpen: this.props.overflowOpen,\n            onMenuOpenChange: (e, { menuOpen }) => {\n              _.invoke(this.props, 'onOverflowOpenChange', e, {\n                ...this.props,\n                overflowOpen: menuOpen,\n              });\n            },\n          },\n        })}\n      </Ref>\n    );\n  }\n\n  renderComponent({ accessibility, ElementType, classes, styles, unhandledProps, rtl }): React.ReactNode {\n    this.rtl = rtl;\n    const { children, items, overflow, overflowItem, variables } = this.props;\n\n    if (!overflow) {\n      return (\n        <Ref innerRef={this.containerRef}>\n          <ElementType className={classes.root} {...accessibility.attributes.root} {...unhandledProps}>\n            <ToolbarVariablesProvider value={variables}>\n              {childrenExist(children) ? children : this.renderItems(items)}\n            </ToolbarVariablesProvider>\n          </ElementType>\n        </Ref>\n      );\n    }\n\n    return (\n      <>\n        <Ref innerRef={this.containerRef}>\n          <ElementType className={classes.root} {...accessibility.attributes.root} {...unhandledProps}>\n            <div className={classes.overflowContainer} ref={this.overflowContainerRef}>\n              <ToolbarVariablesProvider value={variables}>\n                {childrenExist(children) ? children : this.renderItems(this.getVisibleItems())}\n                {this.renderOverflowItem(overflowItem)}\n              </ToolbarVariablesProvider>\n            </div>\n            <div className={classes.offsetMeasure} ref={this.offsetMeasureRef} />\n          </ElementType>\n        </Ref>\n        <EventListener listener={this.handleWindowResize} target={this.context.target.defaultView} type=\"resize\" />\n      </>\n    );\n  }\n}\n\nToolbar.create = createShorthandFactory({ Component: Toolbar, mappedProp: 'content' });\n\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\nexport default withSafeTypeForAs<typeof Toolbar, ToolbarProps>(Toolbar);\n"],"file":"Toolbar.js"}