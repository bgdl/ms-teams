"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _accessibility = require("@fluentui/accessibility");

var _reactBindings = require("@fluentui/react-bindings");

var _reactContextSelector = require("@fluentui/react-context-selector");

var _reactComponentRef = require("@fluentui/react-component-ref");

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var _classnames = _interopRequireDefault(require("classnames"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var React = _interopRequireWildcard(require("react"));

var _reactFela = require("react-fela");

var _positioner = require("../../utils/positioner");

var _utils = require("../../utils");

var _types = require("../../types");

var _Box = _interopRequireDefault(require("../Box/Box"));

var _Label = _interopRequireDefault(require("../Label/Label"));

var _Menu = _interopRequireDefault(require("../Menu/Menu"));

var _Text = _interopRequireDefault(require("../Text/Text"));

var _Reaction = _interopRequireDefault(require("../Reaction/Reaction"));

var _chatItemContext = require("./chatItemContext");

// @ts-ignore
var ChatMessage = function ChatMessage(props) {
  var context = React.useContext(_reactFela.ThemeContext);

  var _useTelemetry = (0, _reactBindings.useTelemetry)(ChatMessage.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var parentAttached = (0, _reactContextSelector.useContextSelector)(_chatItemContext.ChatItemContext, function (v) {
    return v.attached;
  });
  var accessibility = props.accessibility,
      actionMenu = props.actionMenu,
      _props$attached = props.attached,
      attached = _props$attached === void 0 ? parentAttached : _props$attached,
      author = props.author,
      badge = props.badge,
      badgePosition = props.badgePosition,
      children = props.children,
      className = props.className,
      content = props.content,
      design = props.design,
      mine = props.mine,
      positionActionMenu = props.positionActionMenu,
      reactionGroup = props.reactionGroup,
      reactionGroupPosition = props.reactionGroupPosition,
      timestamp = props.timestamp,
      styles = props.styles,
      variables = props.variables,
      overflow = props.unstable_overflow;

  var _React$useState = React.useState(false),
      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
      focused = _React$useState2[0],
      setFocused = _React$useState2[1];

  var _React$useState3 = React.useState(null),
      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),
      messageNode = _React$useState4[0],
      setMessageNode = _React$useState4[1];

  var menuRef = React.useRef();
  var updateActionsMenuPosition = React.useRef(null);
  var getA11Props = (0, _reactBindings.useAccessibility)(accessibility, {
    actionHandlers: {
      // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
      // as navigation (only Tab key should work)
      preventDefault: function preventDefault(event) {
        // preventDefault only if event coming from inside the message
        if (event.currentTarget !== event.target) {
          event.preventDefault();
        }
      },
      focus: function focus(event) {
        if (messageNode) {
          messageNode.focus();
          event.stopPropagation();
        }
      }
    }
  });

  var _useStyles = (0, _reactBindings.useStyles)(ChatMessage.displayName, {
    className: ChatMessage.className,
    mapPropsToStyles: function mapPropsToStyles() {
      return {
        attached: attached,
        badgePosition: badgePosition,
        focused: focused,
        mine: mine,
        hasBadge: !!badge,
        hasReactionGroup: !!reactionGroup
      };
    },
    mapPropsToInlineStyles: function mapPropsToInlineStyles() {
      return {
        className: className,
        design: design,
        styles: styles,
        variables: variables
      };
    },
    rtl: context.rtl
  }),
      classes = _useStyles.classes,
      resolvedStyles = _useStyles.styles;

  var handleFocus = function handleFocus(e) {
    (0, _invoke2.default)(updateActionsMenuPosition, 'current');
    setFocused(true);
    (0, _invoke2.default)(props, 'onFocus', e, props);
  };

  var handleBlur = function handleBlur(e) {
    // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
    // with keyboard the focused element will be changed and there is no way to use `:focus` selector
    var shouldPreserveFocusState = (0, _invoke2.default)(e, 'currentTarget.contains', e.relatedTarget);
    setFocused(shouldPreserveFocusState);
    (0, _invoke2.default)(props, 'onBlur', e, props);
  };

  var handleMouseEnter = function handleMouseEnter(e) {
    (0, _invoke2.default)(updateActionsMenuPosition, 'current');
    (0, _invoke2.default)(props, 'onMouseEnter', e, props);
  };

  var renderActionMenu = function renderActionMenu() {
    var actionMenuElement = _Menu.default.create(actionMenu, {
      defaultProps: function defaultProps() {
        var _ref;

        return _ref = {}, (0, _defineProperty2.default)(_ref, _accessibility.IS_FOCUSABLE_ATTRIBUTE, true), (0, _defineProperty2.default)(_ref, "accessibility", _accessibility.menuAsToolbarBehavior), (0, _defineProperty2.default)(_ref, "className", ChatMessage.slotClassNames.actionMenu), (0, _defineProperty2.default)(_ref, "styles", resolvedStyles.actionMenu), _ref;
      }
    });

    if (!actionMenuElement) {
      return actionMenuElement;
    }

    var messageRect = positionActionMenu && (messageNode === null || messageNode === void 0 ? void 0 : messageNode.getBoundingClientRect());
    var overflowPadding = {
      top: Math.round((messageRect === null || messageRect === void 0 ? void 0 : messageRect.height) || 0)
    };
    return React.createElement(_positioner.Popper, (0, _extends2.default)({
      enabled: positionActionMenu,
      align: "end",
      modifiers: positionActionMenu && {
        // https://popper.js.org/popper-documentation.html#modifiers..flip.behavior
        // Forces to flip only in "top-*" positions
        flip: {
          behavior: ['top']
        },
        preventOverflow: Object.assign({
          escapeWithReference: false,
          // https://popper.js.org/popper-documentation.html#modifiers..preventOverflow.priority
          // Forces to stop prevent overflow on bottom and bottom
          priority: ['left', 'right']
        }, overflow && {
          boundariesElement: 'scrollParent',
          padding: overflowPadding
        })
      },
      position: "above",
      positionFixed: overflow,
      targetRef: messageNode
    }, (0, _positioner.getPopperPropsFromShorthand)(actionMenu)), function (_ref2) {
      var scheduleUpdate = _ref2.scheduleUpdate;
      updateActionsMenuPosition.current = scheduleUpdate;
      return React.createElement(_reactComponentRef.Ref, {
        innerRef: menuRef
      }, actionMenuElement);
    });
  };

  var childrenPropExists = (0, _utils.childrenExist)(children);
  var rootClasses = childrenPropExists ? (0, _classnames.default)(classes.root, classes.content) : classes.root;
  var ElementType = (0, _reactBindings.getElementType)(props);
  var unhandledProps = (0, _reactBindings.useUnhandledProps)(ChatMessage.handledProps, props);

  var badgeElement = _Label.default.create(badge, {
    defaultProps: function defaultProps() {
      return {
        className: ChatMessage.slotClassNames.badge,
        styles: resolvedStyles.badge
      };
    }
  });

  var reactionGroupElement = _Reaction.default.Group.create(reactionGroup, {
    defaultProps: function defaultProps() {
      return {
        className: ChatMessage.slotClassNames.reactionGroup,
        styles: resolvedStyles.reactionGroup
      };
    }
  });

  var actionMenuElement = renderActionMenu();

  var authorElement = _Text.default.create(author, {
    defaultProps: function defaultProps() {
      return {
        size: 'small',
        styles: resolvedStyles.author,
        className: ChatMessage.slotClassNames.author
      };
    }
  });

  var timestampElement = _Text.default.create(timestamp, {
    defaultProps: function defaultProps() {
      return {
        size: 'small',
        styles: resolvedStyles.timestamp,
        timestamp: true,
        className: ChatMessage.slotClassNames.timestamp
      };
    }
  });

  var messageContent = _Box.default.create(content, {
    defaultProps: function defaultProps() {
      return {
        className: ChatMessage.slotClassNames.content,
        styles: resolvedStyles.content
      };
    }
  });

  var element = React.createElement(_reactComponentRef.Ref, {
    innerRef: setMessageNode
  }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, getA11Props('root', Object.assign({
    className: rootClasses,
    onBlur: handleBlur,
    onFocus: handleFocus,
    onMouseEnter: handleMouseEnter
  }, _utils.rtlTextContainer.getAttributes({
    forElements: [children]
  }), {}, unhandledProps)), childrenPropExists ? children : React.createElement(React.Fragment, null, actionMenuElement, badgePosition === 'start' && badgeElement, authorElement, timestampElement, reactionGroupPosition === 'start' && reactionGroupElement, messageContent, reactionGroupPosition === 'end' && reactionGroupElement, badgePosition === 'end' && badgeElement))));
  setEnd();
  return element;
};

ChatMessage.className = 'ui-chat__message';
ChatMessage.displayName = 'ChatMessage';
ChatMessage.defaultProps = {
  accessibility: _accessibility.chatMessageBehavior,
  badgePosition: 'end',
  positionActionMenu: true,
  reactionGroupPosition: 'start'
};
ChatMessage.propTypes = Object.assign({}, _utils.commonPropTypes.createCommon({
  content: 'shorthand'
}), {
  actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
  attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]),
  author: customPropTypes.itemShorthand,
  badge: customPropTypes.itemShorthand,
  badgePosition: PropTypes.oneOf(['start', 'end']),
  mine: PropTypes.bool,
  timestamp: customPropTypes.itemShorthand,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onMouseEnter: PropTypes.func,
  positionActionMenu: PropTypes.bool,
  reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  reactionGroupPosition: PropTypes.oneOf(['start', 'end']),
  unstable_overflow: PropTypes.bool
});
ChatMessage.handledProps = Object.keys(ChatMessage.propTypes);
ChatMessage.create = (0, _utils.createShorthandFactory)({
  Component: ChatMessage,
  mappedProp: 'content'
});
ChatMessage.slotClassNames = {
  actionMenu: "".concat(ChatMessage.className, "__actions"),
  author: "".concat(ChatMessage.className, "__author"),
  timestamp: "".concat(ChatMessage.className, "__timestamp"),
  badge: "".concat(ChatMessage.className, "__badge"),
  content: "".concat(ChatMessage.className, "__content"),
  reactionGroup: "".concat(ChatMessage.className, "__reactions")
};
/**
 * A ChatMessage represents a single message in chat.
 */

var _default = (0, _types.withSafeTypeForAs)(ChatMessage);

exports.default = _default;
//# sourceMappingURL=ChatMessage.js.map
