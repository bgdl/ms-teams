"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var faker = require("faker");
var _ = require("lodash");
var React = require("react");
var ReactDOMServer = require("react-dom/server");
var test_utils_1 = require("react-dom/test-utils");
var isExportedAtTopLevel_1 = require("./isExportedAtTopLevel");
var utils_1 = require("test/utils");
var commonHelpers_1 = require("./commonHelpers");
var FluentUI = require("src/index");
var eventTarget_1 = require("./eventTarget");
/**
 * Assert Component conforms to guidelines that are applicable to all components.
 * @param Component - A component that should conform.
 */
function isConformant(Component, options) {
    if (options === void 0) { options = {}; }
    var _a = options.constructorName, constructorName = _a === void 0 ? Component.prototype.constructor.name : _a, _b = options.eventTargets, eventTargets = _b === void 0 ? {} : _b, _c = options.exportedAtTopLevel, exportedAtTopLevel = _c === void 0 ? true : _c, _d = options.hasAccessibilityProp, hasAccessibilityProp = _d === void 0 ? true : _d, _e = options.requiredProps, requiredProps = _e === void 0 ? {} : _e, _f = options.rendersPortal, rendersPortal = _f === void 0 ? false : _f, _g = options.wrapperComponent, wrapperComponent = _g === void 0 ? null : _g, _h = options.handlesAsProp, handlesAsProp = _h === void 0 ? true : _h, _j = options.autoControlledProps, autoControlledProps = _j === void 0 ? [] : _j;
    var throwError = commonHelpers_1.default('isConformant', Component).throwError;
    var componentType = typeof Component;
    var helperComponentNames = tslib_1.__spreadArrays([react_component_ref_1.Ref, react_component_ref_1.RefFindNode], (wrapperComponent ? [wrapperComponent] : [])).map(utils_1.getDisplayName);
    var toNextNonTrivialChild = function (from) {
        var current = from.childAt(0);
        if (!current)
            return current;
        return helperComponentNames.indexOf(current.name()) === -1 ? current : toNextNonTrivialChild(current);
    };
    var getComponent = function (wrapper) {
        var componentElement = toNextNonTrivialChild(wrapper);
        // passing through Focus Zone wrappers
        if (componentElement.type() === react_bindings_1.FocusZone) {
            // another HOC component is added: FocusZone
            componentElement = componentElement.childAt(0); // skip through <FocusZone>
        }
        // in that case 'topLevelChildElement' we've found so far is a wrapper's topmost child
        // thus, we should continue search
        return wrapperComponent ? toNextNonTrivialChild(componentElement) : componentElement;
    };
    // make sure components are properly exported
    if (componentType !== 'function') {
        throwError("Components should export a class or function, got: " + componentType + ".");
    }
    // tests depend on Component constructor names, enforce them
    if (!constructorName) {
        throwError([
            'Component is not a named function. This should help identify it:\n\n',
            "" + ReactDOMServer.renderToStaticMarkup(React.createElement(Component, null)),
        ].join(''));
    }
    // ----------------------------------------
    // Component info
    // ----------------------------------------
    // This is pretty ugly because:
    // - jest doesn't support custom error messages
    // - jest will run all test
    var infoJSONPath = "docs/src/componentInfo/" + constructorName + ".info.json";
    var info;
    try {
        info = require(infoJSONPath);
    }
    catch (err) {
        // handled in the test() below
        test('component info file exists', function () {
            throw new Error([
                '!! ==========================================================',
                "!! Missing " + infoJSONPath + ".",
                '!! Run `yarn test` or `yarn test:watch` again to generate one.',
                '!! ==========================================================',
            ].join('\n'));
        });
        return null;
    }
    // ----------------------------------------
    // Docblock description
    // ----------------------------------------
    var hasDocblockDescription = info.docblock.description.trim().length > 0;
    test('has a docblock description', function () {
        expect(hasDocblockDescription).toEqual(true);
    });
    if (hasDocblockDescription) {
        var minWords_1 = 5;
        var maxWords_1 = 25;
        test("docblock description is long enough to be meaningful (>" + minWords_1 + " words)", function () {
            expect(_.words(info.docblock.description).length).toBeGreaterThanOrEqual(minWords_1);
        });
        test("docblock description is short enough to be quickly understood (<" + maxWords_1 + " words)", function () {
            expect(_.words(info.docblock.description).length).toBeLessThan(maxWords_1);
        });
    }
    // ----------------------------------------
    // Class and file name
    // ----------------------------------------
    test("constructor name matches filename \"" + constructorName + "\"", function () {
        expect(constructorName).toEqual(info.filenameWithoutExt);
    });
    // find the apiPath in the top level API
    var foundAsSubcomponent = _.isFunction(_.get(FluentUI, info.apiPath));
    exportedAtTopLevel && isExportedAtTopLevel_1.default(constructorName, info.displayName);
    if (info.isChild) {
        test('is a static component on its parent', function () {
            var message = "'" + info.displayName + "' is a child component (is in " + info.repoPath + ")." +
                (" It must be a static prop of its parent '" + info.parentDisplayName + "'");
            expect({ foundAsSubcomponent: foundAsSubcomponent, message: message }).toEqual({
                message: message,
                foundAsSubcomponent: true,
            });
        });
    }
    // ----------------------------------------
    // Props
    // ----------------------------------------
    test('spreads user props', function () {
        var _a;
        var propName = 'data-is-conformant-spread-props';
        var props = (_a = {}, _a[propName] = true, _a);
        var component = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, props)));
        // The component already has the prop, so we are testing if it's children also have the props,
        // that is why we are testing if it is greater then 1
        expect(component.find(props).length).toBeGreaterThan(1);
    });
    if (!rendersPortal && handlesAsProp) {
        describe('"as" prop (common)', function () {
            test('renders the component as HTML tags or passes "as" to the next component', function () {
                // silence element nesting warnings
                utils_1.consoleUtil.disableOnce();
                var tags = ['a', 'em', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'i', 'p', 'span', 'strong'];
                tags.forEach(function (tag) {
                    var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { as: tag })));
                    var component = getComponent(wrapper);
                    try {
                        expect(component.is(tag)).toEqual(true);
                    }
                    catch (err) {
                        expect(component.type()).not.toEqual(Component);
                        expect(component.prop('as')).toEqual(tag);
                    }
                });
            });
            test('renders as a functional component or passes "as" to the next component', function () {
                var MyComponent = function () { return null; };
                var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { as: MyComponent })));
                var component = getComponent(wrapper);
                try {
                    expect(component.type()).toEqual(MyComponent);
                }
                catch (err) {
                    expect(component.type()).not.toEqual(Component);
                    expect(component
                        .find('[as]')
                        .last()
                        .prop('as')).toEqual(MyComponent);
                }
            });
            test('renders as a ReactClass or passes "as" to the next component', function () {
                var MyComponent = /** @class */ (function (_super) {
                    tslib_1.__extends(MyComponent, _super);
                    function MyComponent() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    MyComponent.prototype.render = function () {
                        return React.createElement("div", { "data-my-react-class": true });
                    };
                    return MyComponent;
                }(React.Component));
                var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { as: MyComponent })));
                var component = getComponent(wrapper);
                try {
                    expect(component.type()).toEqual(MyComponent);
                }
                catch (err) {
                    expect(component.type()).not.toEqual(Component);
                    expect(component.prop('as')).toEqual(MyComponent);
                }
            });
            test('passes extra props to the component it is renders as', function () {
                var MyComponent = function () { return null; };
                var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { as: MyComponent, "data-extra-prop": "foo" })));
                expect(wrapper.find('MyComponent[data-extra-prop="foo"]').length).toBeGreaterThan(0);
            });
        });
    }
    describe('handles props', function () {
        var _a;
        test('defines handled props in Component.handledProps', function () {
            expect(Component.handledProps).toBeDefined();
            expect(Array.isArray(Component.handledProps)).toEqual(true);
        });
        test("has 'styles' as handled prop", function () {
            expect(Component.handledProps).toContain('styles');
        });
        test("has 'variables' as handled prop", function () {
            expect(Component.handledProps).toContain('variables');
        });
        test('Component.handledProps includes all handled props', function () {
            var computedProps = _.union(Component.autoControlledProps, _.keys(Component.defaultProps), _.keys(Component.propTypes));
            var expectedProps = _.uniq(computedProps).sort();
            var message = 'Not all handled props were defined in static handledProps. Add all props defined in' +
                ' static autoControlledProps, static defaultProps and static propTypes must be defined' +
                ' in static handledProps.';
            expect({
                message: message,
                handledProps: Component.handledProps.sort(),
            }).toEqual({
                message: message,
                handledProps: expectedProps,
            });
        });
        test('autoControlled props should have prop, default prop and on change handler in handled props', function () {
            autoControlledProps.forEach(function (propName) {
                var capitalisedPropName = "" + propName.slice(0, 1).toUpperCase() + propName.slice(1);
                var expectedDefaultProp = "default" + capitalisedPropName;
                var expectedChangeHandler = propName === 'value' || propName === 'checked' ? 'onChange' : "on" + capitalisedPropName + "Change";
                expect(Component.handledProps).toContain(propName);
                expect(Component.handledProps).toContain(expectedDefaultProp);
                expect(Component.handledProps).toContain(expectedChangeHandler);
            });
        });
        var isClassComponent = !!((_a = Component.prototype) === null || _a === void 0 ? void 0 : _a.isReactComponent);
        if (!isClassComponent) {
            test('uses "useUnhandledProps" hook', function () {
                var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps)));
                var element = getComponent(wrapper);
                expect(element.prop('data-uses-unhanded-props')).toBeTruthy();
            });
        }
    });
    if (hasAccessibilityProp) {
        var role_1 = faker.lorem.word();
        var noopBehavior_1 = function () {
            var _a;
            return ({
                attributes: {
                    root: (_a = {},
                        _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = true,
                        _a.role = role_1,
                        _a),
                },
            });
        };
        test('defines an "accessibility" prop in Component.handledProps', function () {
            expect(Component.handledProps).toContain('accessibility');
        });
        test('spreads "attributes" on root', function () {
            var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { accessibility: noopBehavior_1 })));
            var element = getComponent(wrapper);
            expect(element.prop(accessibility_1.IS_FOCUSABLE_ATTRIBUTE)).toBe(true);
            expect(element.prop('role')).toBe(role_1);
        });
        test("client's attributes override the ones provided by Fluent UI", function () {
            var _a;
            var wrapperProps = tslib_1.__assign(tslib_1.__assign({}, requiredProps), (_a = {}, _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = false, _a));
            var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, wrapperProps, { accessibility: noopBehavior_1 })));
            var element = getComponent(wrapper);
            expect(element.prop(accessibility_1.IS_FOCUSABLE_ATTRIBUTE)).toBe(false);
        });
        _.forEach(['onKeyDown', 'onKeyPress', 'onKeyUp'], function (listenerName) {
            test("handles " + listenerName + " transparently", function () {
                var _a;
                // onKeyDown => keyDown
                var eventName = _.camelCase(listenerName.replace('on', ''));
                var handler = jest.fn();
                var wrapperProps = tslib_1.__assign(tslib_1.__assign({}, requiredProps), (_a = {}, _a[eventTarget_1.EVENT_TARGET_ATTRIBUTE] = true, _a[listenerName] = handler, _a));
                var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, wrapperProps)));
                eventTarget_1.getEventTargetComponent(wrapper, listenerName, eventTargets).simulate(eventName);
                expect(handler).toBeCalledTimes(1);
            });
        });
    }
    // ----------------------------------------
    // Events
    // ----------------------------------------
    test('handles events transparently', function () {
        // Events should be handled transparently, working just as they would in vanilla React.
        // Example, both of these handler()s should be called with the same event:
        //
        //   <Button onClick={handler} />
        //   <button onClick={handler} />
        //
        // This test catches the case where a developer forgot to call the event prop
        // after handling it internally. It also catch cases where the synthetic event was not passed back.
        _.each(utils_1.syntheticEvent.types, function (_a) {
            var eventShape = _a.eventShape, listeners = _a.listeners;
            _.each(listeners, function (listenerName) {
                var _a, _b;
                // onKeyDown => keyDown
                var eventName = _.camelCase(listenerName.replace('on', ''));
                var handlerSpy = jest.fn();
                var props = tslib_1.__assign(tslib_1.__assign({}, requiredProps), (_a = {}, _a[listenerName] = handlerSpy, _a[eventTarget_1.EVENT_TARGET_ATTRIBUTE] = true, _a));
                var component = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, props)));
                var eventTarget = eventTarget_1.getEventTargetComponent(component, listenerName, eventTargets);
                var customHandler = eventTarget.prop(listenerName);
                if (customHandler) {
                    test_utils_1.act(function () {
                        customHandler(eventShape);
                    });
                }
                else {
                    if (Component.propTypes[listenerName]) {
                        throw new Error("Handler for '" + listenerName + "' is not passed to child event emitter element <" + eventTarget.type() + " />");
                    }
                    // We are cheking only props handled by component
                    return;
                }
                // give event listeners opportunity to cleanup
                if (component.instance() && component.instance().componentWillUnmount) {
                    component.instance().componentWillUnmount();
                }
                // <Dropdown onBlur={handleBlur} />
                //                   ^ was not called once on "blur"
                var leftPad = ' '.repeat(info.displayName.length + listenerName.length + 3);
                // onKeyDown => handleKeyDown
                var handlerName = _.camelCase(listenerName.replace('on', 'handle'));
                try {
                    expect(handlerSpy).toHaveBeenCalled();
                }
                catch (err) {
                    throw new Error([
                        "<" + info.displayName + " " + listenerName + "={" + handlerName + "} />\n",
                        leftPad + " ^ was not called once on \"" + eventName + "\".",
                        'You may need to hoist your event handlers up to the root element.\n',
                    ].join(''));
                }
                var expectedArgs = [eventShape];
                var errorMessage = 'was not called with (event)';
                if (_.has(Component.propTypes, listenerName)) {
                    expectedArgs = [eventShape, expect.objectContaining(component.props())];
                    errorMessage = [
                        'was not called with (event, data).\n',
                        "Ensure that 'props' object is passed to '" + listenerName + "'\n",
                        "event handler of <" + Component.displayName + " />.",
                    ].join('');
                }
                // Components should return the event first, then any data
                try {
                    (_b = expect(handlerSpy)).toHaveBeenLastCalledWith.apply(_b, expectedArgs);
                }
                catch (err) {
                    throw new Error([
                        "<" + info.displayName + " " + listenerName + "={" + handlerName + "} />\n",
                        leftPad + " ^ " + errorMessage,
                        'It was called with args:',
                        JSON.stringify(handlerSpy.mock.calls[0], null, 2),
                    ].join('\n'));
                }
            });
        });
    });
    // ----------------------------------------
    // Handles className
    // ----------------------------------------
    describe('static className (common)', function () {
        var componentClassName = info.componentClassName || ("ui-" + Component.displayName).toLowerCase();
        var getClassesOfRootElement = function (component) {
            var classes = component
                .find('[className]')
                .hostNodes()
                .at(wrapperComponent ? 1 : 0)
                .prop('className');
            return classes;
        };
        test("is a static equal to \"" + componentClassName + "\"", function () {
            expect(Component.className).toEqual(componentClassName);
        });
        test("is applied to the root element", function () {
            var component = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps)));
            // only test components that implement className
            if (component.find('[className]').hostNodes().length > 0) {
                expect(_.includes(getClassesOfRootElement(component), componentClassName)).toEqual(true);
            }
        });
        test("applies user's className to root component", function () {
            var className = 'is-conformant-class-string';
            // Portal powered components can render to two elements, a trigger and the actual component
            // The actual component is shown when the portal is open
            // If a trigger is rendered, open the portal and make assertions on the portal element
            // TODO some component using renderPortal = 'true'
            if (rendersPortal) {
                var mountNode = document.createElement('div');
                document.body.appendChild(mountNode);
                var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { className: className })), {
                    attachTo: mountNode,
                });
                wrapper.setProps({ open: true });
                // portals/popups/etc may render the component to somewhere besides descendants
                // we look for the component anywhere in the DOM
                utils_1.assertBodyContains("." + className);
                wrapper.detach();
                document.body.removeChild(mountNode);
            }
            else {
                var component = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { className: className })));
                expect(_.includes(getClassesOfRootElement(component), className)).toEqual(true);
            }
        });
        test("user's className does not override the default classes", function () {
            var component = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps)));
            var defaultClasses = getClassesOfRootElement(component);
            if (!defaultClasses)
                return;
            var userClasses = 'generate';
            var wrapperWithCustomClasses = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps, { className: userClasses })));
            var mixedClasses = getClassesOfRootElement(wrapperWithCustomClasses);
            var message = [
                'Make sure you are using the `getUnhandledProps` util to spread the `unhandledProps` props.',
                'This may also be of help: https://facebook.github.io/react/docs/transferring-props.html.',
            ].join(' ');
            defaultClasses.split(' ').forEach(function (defaultClass) {
                expect({ message: message, result: _.includes(mixedClasses, defaultClass) }).toEqual({
                    message: message,
                    result: true,
                });
            });
        });
    });
    // ----------------------------------------
    // displayName
    // ----------------------------------------
    describe('static displayName (common)', function () {
        test('matches constructor name', function () {
            expect(Component.displayName).toEqual(constructorName);
        });
    });
    // ---------------------------------------
    // Telemetry
    // ---------------------------------------
    describe('telemetry', function () {
        test('reports telemetry to its Provider', function () {
            var telemetry = new react_bindings_1.Telemetry();
            var wrapper = utils_1.mountWithProvider(React.createElement(Component, tslib_1.__assign({}, requiredProps)), {
                wrappingComponentProps: { telemetry: telemetry },
            });
            wrapper.unmount();
            expect(telemetry.performance).toHaveProperty(Component.displayName);
        });
    });
}
exports.default = isConformant;
