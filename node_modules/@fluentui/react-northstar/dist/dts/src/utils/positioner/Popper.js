"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var _ = require("lodash");
var _PopperJS = require("popper.js");
var React = require("react");
var isBrowser_1 = require("../isBrowser");
var getScrollParent_1 = require("./getScrollParent");
var positioningHelper_1 = require("./positioningHelper");
/**
 * Memoize a result using deep equality. This hook has two advantages over
 * React.useMemo: it uses deep equality to compare memo keys, and it guarantees
 * that the memo function will only be called if the keys are unequal.
 * React.useMemo cannot be relied on to do this, since it is only a performance
 * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).
 *
 * Copied from https://github.com/apollographql/react-apollo/blob/master/packages/hooks/src/utils/useDeepMemo.ts.
 */
function useDeepMemo(memoFn, key) {
    var ref = React.useRef();
    if (!ref.current || !_.isEqual(key, ref.current.key)) {
        ref.current = { key: key, value: memoFn() };
    }
    return ref.current.value;
}
// `popper.js` has a UMD build without `.default`, it breaks CJS builds:
// https://github.com/rollup/rollup/issues/1267#issuecomment-446681320
var createPopper = function (reference, popper, options) {
    var instance = new (_PopperJS.default || _PopperJS)(reference, popper, tslib_1.__assign(tslib_1.__assign({}, options), { eventsEnabled: false }));
    var originalUpdate = instance.update;
    instance.update = function () {
        // Fix Popper.js initial positioning display issue
        // https://github.com/popperjs/popper.js/issues/457#issuecomment-367692177
        popper.style.left = '0';
        popper.style.top = '0';
        originalUpdate();
    };
    var actualWindow = popper.ownerDocument.defaultView;
    instance.scheduleUpdate = function () { return actualWindow.requestAnimationFrame(instance.update); };
    instance.enableEventListeners();
    return instance;
};
/**
 * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.
 */
var Popper = function (props) {
    var align = props.align, children = props.children, enabled = props.enabled, flipBoundary = props.flipBoundary, userModifiers = props.modifiers, offset = props.offset, overflowBoundary = props.overflowBoundary, pointerTargetRef = props.pointerTargetRef, position = props.position, positionFixed = props.positionFixed, _a = props.positioningDependencies, positioningDependencies = _a === void 0 ? [] : _a, rtl = props.rtl, targetRef = props.targetRef, unstable_pinned = props.unstable_pinned;
    var proposedPlacement = positioningHelper_1.getPlacement({ align: align, position: position, rtl: rtl });
    var popperRef = React.useRef();
    var contentRef = React.useRef(null);
    var latestPlacement = React.useRef(proposedPlacement);
    var _b = React.useState(proposedPlacement), computedPlacement = _b[0], setComputedPlacement = _b[1];
    var hasDocument = isBrowser_1.default();
    var hasScrollableElement = React.useMemo(function () {
        if (hasDocument) {
            var scrollParentElement = getScrollParent_1.default(contentRef.current);
            return scrollParentElement !== scrollParentElement.ownerDocument.body;
        }
        return false;
    }, [contentRef, hasDocument]);
    // Is a broken dependency and can cause potential bugs, we should rethink this as all other refs
    // in this component.
    var computedModifiers = useDeepMemo(function () {
        return _.merge(
        /**
         * This prevents blurrines in chrome, when the coordinates are odd numbers alternative
         * would be to use `fn` and manipulate the computed style or ask popper to fix it but
         * since there is presumably only handful of poppers displayed on the page, the
         * performance impact should be minimal.
         */
        { computeStyle: { gpuAcceleration: false } }, { flip: { padding: 0, flipVariationsByContent: true } }, { preventOverflow: { padding: 0 } }, offset && {
            offset: { offset: rtl ? positioningHelper_1.applyRtlToOffset(offset, position) : offset },
            keepTogether: { enabled: false },
        }, 
        /**
         * When the popper box is placed in the context of a scrollable element, we need to set
         * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent'
         * (default is 'viewport') so that the popper box will stick with the targetRef when we
         * scroll targetRef out of the viewport.
         */
        hasScrollableElement && {
            preventOverflow: { escapeWithReference: true },
            flip: { boundariesElement: 'scrollParent' },
        }, flipBoundary && { flip: { boundariesElement: flipBoundary } }, overflowBoundary && { preventOverflow: { boundariesElement: overflowBoundary } }, userModifiers, 
        /**
         * unstable_pinned disables the flip modifier by setting flip.enabled to false; this
         * disables automatic repositioning of the popper box; it will always be placed according to
         * the values of `align` and `position` props, regardless of the size of the component, the
         * reference element or the viewport.
         */
        unstable_pinned && { flip: { enabled: false } });
    }, [hasScrollableElement, position, offset, rtl, unstable_pinned, userModifiers]);
    var scheduleUpdate = React.useCallback(function () {
        if (popperRef.current) {
            popperRef.current.scheduleUpdate();
        }
    }, []);
    var destroyInstance = React.useCallback(function () {
        if (popperRef.current) {
            popperRef.current.destroy();
            if (popperRef.current.popper) {
                // Popper keeps a reference to the DOM node, which needs to be cleaned up
                // temporarily fix it here until fixed properly in popper
                popperRef.current.popper = null;
            }
            popperRef.current = null;
        }
    }, []);
    var createInstance = React.useCallback(function () {
        destroyInstance();
        var reference = targetRef && react_component_ref_1.isRefObject(targetRef)
            ? targetRef.current
            : targetRef;
        if (!enabled || !reference || !contentRef.current) {
            return;
        }
        var hasPointer = !!(pointerTargetRef && pointerTargetRef.current);
        var handleUpdate = function (data) {
            // PopperJS performs computations that might update the computed placement: auto positioning, flipping the
            // placement in case the popper box should be rendered at the edge of the viewport and does not fit
            if (data.placement !== latestPlacement.current) {
                latestPlacement.current = data.placement;
                setComputedPlacement(data.placement);
            }
        };
        var options = {
            placement: proposedPlacement,
            positionFixed: positionFixed,
            modifiers: tslib_1.__assign(tslib_1.__assign({}, computedModifiers), { 
                /**
                 * This modifier is necessary in order to render the pointer. Refs are resolved in effects, so it can't be
                 * placed under computed modifiers. Deep merge is not required as this modifier has only these properties.
                 * `arrow` modifier also requires `keepTogether`.
                 */
                keepTogether: { enabled: hasPointer }, arrow: {
                    enabled: hasPointer,
                    element: pointerTargetRef && pointerTargetRef.current,
                } }),
            onCreate: handleUpdate,
            onUpdate: handleUpdate,
        };
        popperRef.current = createPopper(reference, contentRef.current, options);
    }, [
        // TODO review dependencies for popperHasScrollableParent
        enabled,
        computedModifiers,
        pointerTargetRef,
        positionFixed,
        proposedPlacement,
        targetRef,
        unstable_pinned,
    ]);
    react_bindings_1.useIsomorphicLayoutEffect(function () {
        createInstance();
        return destroyInstance;
    }, [createInstance]);
    React.useEffect(scheduleUpdate, tslib_1.__spreadArrays(positioningDependencies, [computedPlacement]));
    var child = typeof children === 'function'
        ? children({ placement: computedPlacement, scheduleUpdate: scheduleUpdate })
        : children;
    return child ? React.createElement(react_component_ref_1.Ref, { innerRef: contentRef }, React.Children.only(child)) : null;
};
Popper.defaultProps = {
    enabled: true,
    positionFixed: false,
    positioningDependencies: [],
};
exports.default = Popper;
