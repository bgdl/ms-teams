"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var React = require("react");
var _ = require("lodash");
var customPropTypes = require("@fluentui/react-proptypes");
var PropTypes = require("prop-types");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_bindings_1 = require("@fluentui/react-bindings");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
var ToolbarCustomItem_1 = require("./ToolbarCustomItem");
var ToolbarDivider_1 = require("./ToolbarDivider");
var ToolbarItem_1 = require("./ToolbarItem");
var ToolbarMenu_1 = require("./ToolbarMenu");
var ToolbarMenuDivider_1 = require("./ToolbarMenuDivider");
var ToolbarMenuItem_1 = require("./ToolbarMenuItem");
var ToolbarMenuRadioGroup_1 = require("./ToolbarMenuRadioGroup");
var ToolbarRadioGroup_1 = require("./ToolbarRadioGroup");
var toolbarVariablesContext_1 = require("./toolbarVariablesContext");
var react_icons_northstar_1 = require("@fluentui/react-icons-northstar");
var WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';
var Toolbar = /** @class */ (function (_super) {
    tslib_1.__extends(Toolbar, _super);
    function Toolbar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.overflowContainerRef = React.createRef();
        _this.overflowItemRef = React.createRef();
        _this.offsetMeasureRef = React.createRef();
        _this.containerRef = React.createRef();
        _this.hideOverflowItems = function () {
            var $overflowContainer = _this.overflowContainerRef.current;
            var $overflowItem = _this.overflowItemRef.current;
            var $offsetMeasure = _this.offsetMeasureRef.current;
            if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {
                return;
            }
            // workaround: when resizing window with popup opened the container contents scroll for some reason
            if (_this.rtl) {
                $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);
            }
            else {
                $overflowContainer.scrollTo(0, 0);
            }
            var $items = $overflowContainer.children;
            var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();
            var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();
            var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect();
            // Absolute positioning offset
            // Overflow menu is absolutely positioned relative to root slot
            // If there is padding set on the root slot boundingClientRect computations use inner content box,
            // but absolute position is relative to root slot's PADDING box.
            // We compute absolute positioning offset
            // By measuring position of an offsetMeasure element absolutely positioned to 0,0.
            // TODO: replace by getComputedStyle('padding')
            var absolutePositioningOffset = {
                horizontal: _this.rtl
                    ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right
                    : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,
                vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top,
            };
            var isOverflowing = false;
            var $lastVisibleItem;
            var lastVisibleItemRect;
            // check all items from the last one back
            _.forEachRight($items, function ($item, i) {
                if ($item === $overflowItem) {
                    return true;
                }
                var itemBoundingRect = $item.getBoundingClientRect();
                // if the item is out of the crop rectangle, hide it
                if (_this.isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {
                    isOverflowing = true;
                    // console.log('Overflow', i, {
                    //   item: [itemBoundingRect.left, itemBoundingRect.right],
                    //   crop: [
                    //     overflowContainerBoundingRect.left,
                    //     overflowContainerBoundingRect.right,
                    //     overflowContainerBoundingRect.width,
                    //   ],
                    //   container: $overflowContainer,
                    // })
                    _this.hide($item);
                    return true;
                }
                // if there is an overflow, check collision of remaining items with eventual overflow position
                if (isOverflowing &&
                    !$lastVisibleItem &&
                    _this.wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {
                    _this.hide($item);
                    return true;
                }
                // Remember the last visible item
                if (!$lastVisibleItem) {
                    $lastVisibleItem = $item;
                    lastVisibleItemRect = itemBoundingRect;
                    _this.lastVisibleItemIndex = i;
                }
                return _this.show($item); // exit the loop when first visible item is found
            });
            // if there is an overflow,  position and show overflow item, otherwise hide it
            if (isOverflowing || _this.props.overflowOpen) {
                $overflowItem.style.position = 'absolute';
                _this.setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);
                _this.show($overflowItem);
            }
            else {
                _this.lastVisibleItemIndex = _this.props.items.length - 1;
                _this.hide($overflowItem);
            }
            _.invoke(_this.props, 'onOverflow', _this.lastVisibleItemIndex + 1);
        };
        _this.getOverflowItems = function () {
            // console.log('getOverflowItems()', this.props.items.slice(this.lastVisibleItemIndex + 1))
            return _this.props.getOverflowItems
                ? _this.props.getOverflowItems(_this.lastVisibleItemIndex + 1)
                : _this.props.items.slice(_this.lastVisibleItemIndex + 1);
        };
        _this.getVisibleItems = function () {
            // console.log('allItems()', this.props.items)
            var end = _this.props.overflowOpen ? _this.lastVisibleItemIndex + 1 : _this.props.items.length;
            // console.log('getVisibleItems()', this.props.items.slice(0, end))
            return _this.props.items.slice(0, end);
        };
        _this.handleWindowResize = _.debounce(function (e) {
            _this.hideOverflowItems();
            if (_this.props.overflowOpen) {
                _.invoke(_this.props, 'onOverflowOpenChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { overflowOpen: false }));
            }
        }, 16);
        return _this;
    }
    Toolbar.prototype.renderItems = function (items) {
        return _.map(items, function (item) {
            var kind = _.get(item, 'kind', 'item');
            switch (kind) {
                case 'divider':
                    return ToolbarDivider_1.default.create(item);
                case 'group':
                    return ToolbarRadioGroup_1.default.create(item);
                case 'toggle':
                    return ToolbarItem_1.default.create(item, {
                        defaultProps: function () { return ({ accessibility: accessibility_1.toggleButtonBehavior }); },
                    });
                case 'custom':
                    return ToolbarCustomItem_1.default.create(item);
                default:
                    return ToolbarItem_1.default.create(item);
            }
        });
    };
    Toolbar.prototype.hide = function (el) {
        if (el.style.visibility === 'hidden') {
            return;
        }
        if (this.context.target.activeElement === el || el.contains(this.context.target.activeElement)) {
            if (this.containerRef.current) {
                var firstFocusableItem = react_bindings_1.getFirstFocusable(this.containerRef.current, this.containerRef.current.firstElementChild);
                if (firstFocusableItem) {
                    firstFocusableItem.focus();
                }
            }
        }
        el.style.visibility = 'hidden';
        var wasFocusable = el.getAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE);
        if (wasFocusable) {
            el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);
        }
        el.setAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE, 'false');
    };
    Toolbar.prototype.show = function (el) {
        if (el.style.visibility !== 'hidden') {
            return false;
        }
        el.style.visibility = null;
        var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);
        if (wasFocusable) {
            el.setAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE, wasFocusable);
            el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);
        }
        else {
            el.removeAttribute(accessibility_1.IS_FOCUSABLE_ATTRIBUTE);
        }
        return true;
    };
    /**
     * Checks if `item` overflows a `container`.
     * TODO: check and fix all margin combination
     */
    Toolbar.prototype.isItemOverflowing = function (itemBoundingRect, containerBoundingRect) {
        return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;
    };
    /**
     * Checks if `item` would collide with eventual position of `overflowItem`.
     */
    Toolbar.prototype.wouldItemCollide = function ($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {
        var actualWindow = this.context.target.defaultView;
        var wouldCollide;
        if (this.rtl) {
            var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;
            wouldCollide =
                itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left;
            // console.log('Collision [RTL]', {
            //   wouldCollide,
            //   'itemBoundingRect.left': itemBoundingRect.left,
            //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
            //   itemRightMargin: itemLeftMargin,
            //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,
            //   'overflowContainerBoundingRect.left': containerBoundingRect.left,
            // })
        }
        else {
            var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;
            wouldCollide =
                itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right;
            // console.log('Collision', {
            //   wouldCollide,
            //   'itemBoundingRect.right': itemBoundingRect.right,
            //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
            //   itemRightMargin,
            //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,
            //   'overflowContainerBoundingRect.right': containerBoundingRect.right,
            // })
        }
        return wouldCollide;
    };
    /**
     * Positions overflowItem next to lastVisible item
     * TODO: consider overflowItem margin
     */
    Toolbar.prototype.setOverflowPosition = function ($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {
        var actualWindow = this.context.target.defaultView;
        if ($lastVisibleItem) {
            if (this.rtl) {
                var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;
                $overflowItem.style.right = containerBoundingRect.right -
                    lastVisibleItemRect.left +
                    lastVisibleItemMarginLeft +
                    absolutePositioningOffset.horizontal + "px";
            }
            else {
                var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;
                $overflowItem.style.left = lastVisibleItemRect.right -
                    containerBoundingRect.left +
                    lastVisibleItemRightMargin +
                    absolutePositioningOffset.horizontal + "px";
            }
        }
        else {
            // there is no last visible item -> position the overflow as the first item
            this.lastVisibleItemIndex = -1;
            if (this.rtl) {
                $overflowItem.style.right = absolutePositioningOffset.horizontal + "px";
            }
            else {
                $overflowItem.style.left = absolutePositioningOffset.horizontal + "px";
            }
        }
    };
    Toolbar.prototype.componentDidMount = function () {
        this.afterComponentRendered();
    };
    Toolbar.prototype.componentDidUpdate = function () {
        this.afterComponentRendered();
    };
    Toolbar.prototype.componentWillUnmount = function () {
        if (this.animationFrameId !== undefined) {
            this.context.target.defaultView.cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = undefined;
        }
    };
    Toolbar.prototype.afterComponentRendered = function () {
        var _this = this;
        var actualWindow = this.context.target.defaultView;
        if (this.animationFrameId !== undefined) {
            actualWindow.cancelAnimationFrame(this.animationFrameId);
        }
        // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary
        this.animationFrameId = actualWindow.requestAnimationFrame(function () {
            _this.hideOverflowItems();
        });
    };
    Toolbar.prototype.renderOverflowItem = function (overflowItem) {
        var _this = this;
        return (React.createElement(react_component_ref_1.Ref, { innerRef: this.overflowItemRef }, ToolbarItem_1.default.create(overflowItem, {
            defaultProps: function () { return ({
                // TODO: ups
                icon: React.createElement(react_icons_northstar_1.MoreIcon, tslib_1.__assign({}, { outline: true })),
            }); },
            overrideProps: {
                menu: this.props.overflowOpen ? this.getOverflowItems() : [],
                menuOpen: this.props.overflowOpen,
                onMenuOpenChange: function (e, _a) {
                    var menuOpen = _a.menuOpen;
                    _.invoke(_this.props, 'onOverflowOpenChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { overflowOpen: menuOpen }));
                },
            },
        })));
    };
    Toolbar.prototype.renderComponent = function (_a) {
        var accessibility = _a.accessibility, ElementType = _a.ElementType, classes = _a.classes, styles = _a.styles, unhandledProps = _a.unhandledProps, rtl = _a.rtl;
        this.rtl = rtl;
        var _b = this.props, children = _b.children, items = _b.items, overflow = _b.overflow, overflowItem = _b.overflowItem, variables = _b.variables;
        if (!overflow) {
            return (React.createElement(react_component_ref_1.Ref, { innerRef: this.containerRef },
                React.createElement(ElementType, tslib_1.__assign({ className: classes.root }, accessibility.attributes.root, unhandledProps),
                    React.createElement(toolbarVariablesContext_1.ToolbarVariablesProvider, { value: variables }, utils_1.childrenExist(children) ? children : this.renderItems(items)))));
        }
        return (React.createElement(React.Fragment, null,
            React.createElement(react_component_ref_1.Ref, { innerRef: this.containerRef },
                React.createElement(ElementType, tslib_1.__assign({ className: classes.root }, accessibility.attributes.root, unhandledProps),
                    React.createElement("div", { className: classes.overflowContainer, ref: this.overflowContainerRef },
                        React.createElement(toolbarVariablesContext_1.ToolbarVariablesProvider, { value: variables },
                            utils_1.childrenExist(children) ? children : this.renderItems(this.getVisibleItems()),
                            this.renderOverflowItem(overflowItem))),
                    React.createElement("div", { className: classes.offsetMeasure, ref: this.offsetMeasureRef }))),
            React.createElement(react_component_event_listener_1.EventListener, { listener: this.handleWindowResize, target: this.context.target.defaultView, type: "resize" })));
    };
    Toolbar.className = 'ui-toolbar';
    Toolbar.displayName = 'Toolbar';
    Toolbar.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon()), { items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']), overflow: PropTypes.bool, overflowOpen: PropTypes.bool, overflowItem: customPropTypes.shorthandAllowingChildren, onOverflow: PropTypes.func, onOverflowOpenChange: PropTypes.func, getOverflowItems: PropTypes.func });
    Toolbar.defaultProps = {
        accessibility: accessibility_1.toolbarBehavior,
        items: [],
        overflowItem: {},
    };
    Toolbar.CustomItem = ToolbarCustomItem_1.default;
    Toolbar.Divider = ToolbarDivider_1.default;
    Toolbar.Item = ToolbarItem_1.default;
    Toolbar.Menu = ToolbarMenu_1.default;
    Toolbar.MenuDivider = ToolbarMenuDivider_1.default;
    Toolbar.MenuItem = ToolbarMenuItem_1.default;
    Toolbar.MenuRadioGroup = ToolbarMenuRadioGroup_1.default;
    Toolbar.RadioGroup = ToolbarRadioGroup_1.default;
    return Toolbar;
}(utils_1.UIComponent));
Toolbar.create = utils_1.createShorthandFactory({ Component: Toolbar, mappedProp: 'content' });
/**
 * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).
 *
 * @accessibility
 *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.
 * @accessibilityIssues
 * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)
 */
exports.default = types_1.withSafeTypeForAs(Toolbar);
