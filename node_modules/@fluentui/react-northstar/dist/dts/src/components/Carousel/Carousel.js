"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var customPropTypes = require("@fluentui/react-proptypes");
var accessibility_1 = require("@fluentui/accessibility");
var React = require("react");
var _ = require("lodash");
var PropTypes = require("prop-types");
var classnames_1 = require("classnames");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var Animation_1 = require("../Animation/Animation");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
var CarouselItem_1 = require("./CarouselItem");
var Text_1 = require("../Text/Text");
var CarouselNavigation_1 = require("./CarouselNavigation");
var CarouselNavigationItem_1 = require("./CarouselNavigationItem");
var CarouselPaddle_1 = require("./CarouselPaddle");
var Carousel = /** @class */ (function (_super) {
    tslib_1.__extends(Carousel, _super);
    function Carousel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.actionHandlers = {
            showNextSlideByKeyboardNavigation: function (e) {
                e.preventDefault();
                _this.showNextSlide(e, true);
            },
            showPreviousSlideByKeyboardNavigation: function (e) {
                e.preventDefault();
                _this.showPreviousSlide(e, true);
            },
            showNextSlideByPaddlePress: function (e) {
                e.preventDefault();
                _this.showNextSlide(e, false);
                _this.handleNextPaddleFocus();
            },
            showPreviousSlideByPaddlePress: function (e) {
                e.preventDefault();
                _this.showPreviousSlide(e, false);
                _this.handlePreviousPaddleFocus();
            },
        };
        _this.itemRefs = [];
        _this.paddleNextRef = React.createRef();
        _this.paddlePreviousRef = React.createRef();
        _this.focusItemAtIndex = _.debounce(function (index) {
            _this.itemRefs[index].current.focus();
        }, 400);
        _this.overrideItemProps = function (predefinedProps) { return ({
            onFocus: function (e, itemProps) {
                _this.setState({
                    shouldFocusContainer: e.currentTarget === e.target,
                    isFromKeyboard: utils_1.isFromKeyboard(),
                });
                _.invoke(predefinedProps, 'onFocus', e, itemProps);
            },
            onBlur: function (e, itemProps) {
                _this.setState({
                    shouldFocusContainer: e.currentTarget.contains(e.relatedTarget),
                    isFromKeyboard: false,
                });
                _.invoke(predefinedProps, 'onBlur', e, itemProps);
            },
        }); };
        _this.renderContent = function (accessibility, classes, unhandledProps) {
            var _a = _this.props, getItemPositionText = _a.getItemPositionText, items = _a.items, circular = _a.circular;
            var _b = _this.state, activeIndex = _b.activeIndex, itemIds = _b.itemIds, prevActiveIndex = _b.prevActiveIndex;
            _this.itemRefs = [];
            return (React.createElement("div", tslib_1.__assign({ className: classes.itemsContainerWrapper }, accessibility.attributes.itemsContainerWrapper),
                React.createElement("div", tslib_1.__assign({ className: classnames_1.default(Carousel.slotClassNames.itemsContainer, classes.itemsContainer) }, accessibility.attributes.itemsContainer, utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.itemsContainer, unhandledProps)), items &&
                    items.map(function (item, index) {
                        var itemRef = React.createRef();
                        _this.itemRefs.push(itemRef);
                        var active = activeIndex === index;
                        var slideToNext = prevActiveIndex < activeIndex;
                        var initialMounting = prevActiveIndex === -1;
                        if (circular && prevActiveIndex === items.length - 1 && activeIndex === 0) {
                            slideToNext = true;
                        }
                        else if (circular && prevActiveIndex === 0 && activeIndex === items.length - 1) {
                            slideToNext = false;
                        }
                        return (React.createElement(Animation_1.default, { key: item['key'] || index, mountOnEnter: true, unmountOnExit: true, visible: active, name: initialMounting
                                ? ''
                                : active
                                    ? slideToNext
                                        ? 'carousel-slide-to-next-enter'
                                        : 'carousel-slide-to-previous-enter'
                                    : slideToNext
                                        ? 'carousel-slide-to-next-exit'
                                        : 'carousel-slide-to-previous-exit' },
                            React.createElement(react_component_ref_1.Ref, { innerRef: itemRef }, CarouselItem_1.default.create(item, {
                                defaultProps: function () { return (tslib_1.__assign({ active: active, id: itemIds[index], navigation: !!_this.props.navigation }, (getItemPositionText && {
                                    itemPositionText: getItemPositionText(index, items.length),
                                }))); },
                                overrideProps: _this.overrideItemProps,
                            }))));
                    }))));
        };
        _this.handleNextPaddleFocus = function () {
            // if 'next' paddle will disappear, will focus 'previous' one.
            if (!_this.props.navigation && _this.state.activeIndex >= _this.props.items.length - 2 && !_this.props.circular) {
                _this.paddlePreviousRef.current.focus();
            }
        };
        _this.handlePreviousPaddleFocus = function () {
            // if 'previous' paddle will disappear, will focus 'next' one.
            if (!_this.props.navigation && _this.state.activeIndex <= 1 && !_this.props.circular) {
                _this.paddleNextRef.current.focus();
            }
        };
        _this.showPreviousSlide = function (e, focusItem) {
            _this.setActiveIndex(e, _this.state.activeIndex - 1, focusItem);
        };
        _this.showNextSlide = function (e, focusItem) {
            _this.setActiveIndex(e, _this.state.activeIndex + 1, focusItem);
        };
        _this.handlePaddleOverrides = function (predefinedProps, paddleName) { return ({
            onClick: function (e, paddleProps) {
                _.invoke(predefinedProps, 'onClick', e, paddleProps);
                if (paddleName === 'paddleNext') {
                    _this.showNextSlide(e, false);
                    _this.handleNextPaddleFocus();
                }
                else if (paddleName === 'paddlePrevious') {
                    _this.showPreviousSlide(e, false);
                    _this.handlePreviousPaddleFocus();
                }
            },
            onBlur: function (e, paddleProps) {
                if (e.relatedTarget !== _this.paddleNextRef.current) {
                    _this.setState({ ariaLiveOn: false });
                }
            },
            onFocus: function (e, paddleProps) {
                _.invoke(predefinedProps, 'onFocus', e, paddleProps);
                _this.setState({
                    ariaLiveOn: true,
                });
            },
        }); };
        _this.renderPaddles = function (accessibility) {
            var _a = _this.props, paddlePrevious = _a.paddlePrevious, paddleNext = _a.paddleNext, items = _a.items, circular = _a.circular;
            var activeIndex = _this.state.activeIndex;
            return (React.createElement(React.Fragment, null,
                React.createElement(react_component_ref_1.Ref, { innerRef: _this.paddlePreviousRef }, CarouselPaddle_1.default.create(paddlePrevious, {
                    defaultProps: function () { return (tslib_1.__assign(tslib_1.__assign({ className: Carousel.slotClassNames.paddlePrevious, previous: true, hidden: items !== undefined && !circular && activeIndex === 0 }, accessibility.attributes.paddlePrevious), utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.paddlePrevious, paddlePrevious))); },
                    overrideProps: function (predefinedProps) {
                        return _this.handlePaddleOverrides(predefinedProps, 'paddlePrevious');
                    },
                })),
                React.createElement(react_component_ref_1.Ref, { innerRef: _this.paddleNextRef }, CarouselPaddle_1.default.create(paddleNext, {
                    defaultProps: function () { return (tslib_1.__assign(tslib_1.__assign({ className: Carousel.slotClassNames.paddleNext, next: true, hidden: items !== undefined && !circular && activeIndex === items.length - 1 }, accessibility.attributes.paddleNext), utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.paddleNext, paddleNext))); },
                    overrideProps: function (predefinedProps) {
                        return _this.handlePaddleOverrides(predefinedProps, 'paddleNext');
                    },
                }))));
        };
        _this.renderNavigation = function () {
            var _a = _this.props, getItemPositionText = _a.getItemPositionText, navigation = _a.navigation, items = _a.items;
            if (!items || !items.length) {
                return null;
            }
            var activeIndex = _this.state.activeIndex;
            return navigation ? (CarouselNavigation_1.default.create(navigation, {
                defaultProps: function () { return ({
                    className: Carousel.slotClassNames.navigation,
                    iconOnly: true,
                    activeIndex: activeIndex,
                }); },
                overrideProps: function (predefinedProps) { return ({
                    onItemClick: function (e, itemProps) {
                        var index = itemProps.index;
                        _this.setActiveIndex(e, index, true);
                        _.invoke(predefinedProps, 'onClick', e, itemProps);
                    },
                }); },
            })) : (React.createElement(Text_1.default, { "aria-hidden": "true", className: Carousel.slotClassNames.pagination, content: getItemPositionText(activeIndex, items.length) }));
        };
        return _this;
    }
    Carousel.getAutoControlledStateFromProps = function (props, state) {
        var items = props.items;
        var itemIds = state.itemIds;
        if (!items) {
            return null;
        }
        return {
            itemIds: items.map(function (item, index) { return utils_1.getOrGenerateIdFromShorthand('carousel-item-', item, itemIds[index]); }),
        };
    };
    Carousel.prototype.componentWillUnmount = function () {
        this.focusItemAtIndex.cancel();
    };
    Carousel.prototype.getInitialAutoControlledState = function () {
        return {
            activeIndex: 0,
            prevActiveIndex: -1,
            ariaLiveOn: false,
            itemIds: [],
            shouldFocusContainer: false,
            isFromKeyboard: false,
        };
    };
    Carousel.prototype.setActiveIndex = function (e, index, focusItem) {
        var _a = this.props, circular = _a.circular, items = _a.items;
        var lastItemIndex = items.length - 1;
        var activeIndex = index;
        if (index < 0) {
            if (!circular) {
                return;
            }
            activeIndex = lastItemIndex;
        }
        if (index > lastItemIndex) {
            if (!circular) {
                return;
            }
            activeIndex = 0;
        }
        this.setState({
            prevActiveIndex: this.state.activeIndex,
            activeIndex: activeIndex,
        });
        _.invoke(this.props, 'onActiveIndexChange', e, this.props);
        if (focusItem) {
            this.focusItemAtIndex(activeIndex);
        }
    };
    Carousel.prototype.renderComponent = function (_a) {
        var ElementType = _a.ElementType, classes = _a.classes, accessibility = _a.accessibility, unhandledProps = _a.unhandledProps;
        var children = this.props.children;
        return (React.createElement(ElementType, tslib_1.__assign({ className: classes.root }, accessibility.attributes.root, unhandledProps, utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps)), utils_1.childrenExist(children) ? (children) : (React.createElement(React.Fragment, null,
            this.renderContent(accessibility, classes, unhandledProps),
            this.renderPaddles(accessibility),
            this.renderNavigation()))));
    };
    Carousel.displayName = 'Carousel';
    Carousel.className = 'ui-carousel';
    Carousel.slotClassNames = {
        itemsContainer: Carousel.className + "__itemscontainer",
        paddleNext: Carousel.className + "__paddlenext",
        paddlePrevious: Carousel.className + "__paddleprevious",
        pagination: Carousel.className + "__pagination",
        navigation: Carousel.className + "__navigation",
    };
    Carousel.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        content: false,
    })), { activeIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]), ariaRoleDescription: PropTypes.string, ariaLabel: PropTypes.string, circular: PropTypes.bool, defaultActiveIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]), getItemPositionText: PropTypes.func, items: customPropTypes.collectionShorthand, navigation: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]), navigationPosition: PropTypes.string, onActiveIndexChange: PropTypes.func, paddleNext: customPropTypes.itemShorthand, paddlesPosition: PropTypes.string, paddlePrevious: customPropTypes.itemShorthand });
    Carousel.autoControlledProps = ['activeIndex'];
    Carousel.defaultProps = {
        accessibility: accessibility_1.carouselBehavior,
        paddlePrevious: {},
        paddleNext: {},
    };
    Carousel.Item = CarouselItem_1.default;
    Carousel.Navigation = CarouselNavigation_1.default;
    Carousel.NavigationItem = CarouselNavigationItem_1.default;
    Carousel.Paddle = CarouselPaddle_1.default;
    return Carousel;
}(utils_1.AutoControlledComponent));
Carousel.create = utils_1.createShorthandFactory({
    Component: Carousel,
    mappedArrayProp: 'items',
});
/**
 * A Carousel displays data organised as a gallery.
 *
 * @accessibility
 * Implements [ARIA Carousel](https://www.w3.org/WAI/tutorials/carousels/structure/) design pattern.
 * @accessibilityIssues
 * [VoiceOver doens't narrate label referenced by aria-labelledby attribute, when role is "tabpanel"](https://bugs.chromium.org/p/chromium/issues/detail?id=1040924)
 */
exports.default = types_1.withSafeTypeForAs(Carousel);
