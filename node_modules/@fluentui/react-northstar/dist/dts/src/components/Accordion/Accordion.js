"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var AccordionTitle_1 = require("./AccordionTitle");
var AccordionContent_1 = require("./AccordionContent");
var types_1 = require("../../types");
var FocusContainer_1 = require("../../utils/accessibility/FocusHandling/FocusContainer");
var Accordion = /** @class */ (function (_super) {
    tslib_1.__extends(Accordion, _super);
    function Accordion(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.focusHandler = null;
        _this.itemRefs = [];
        _this.defaultAccordionTitleId = _.uniqueId('accordion-title-');
        _this.defaultAccordionContentId = _.uniqueId('accordion-content-');
        _this.actionHandlers = {
            moveNext: function (e) {
                e.preventDefault();
                _this.focusHandler.moveNext();
            },
            movePrevious: function (e) {
                e.preventDefault();
                _this.focusHandler.movePrevious();
            },
            moveFirst: function (e) {
                e.preventDefault();
                _this.focusHandler.moveFirst();
            },
            moveLast: function (e) {
                e.preventDefault();
                _this.focusHandler.moveLast();
            },
        };
        _this.handleNavigationFocus = function (index) {
            _this.setState({ focusedIndex: index }, function () {
                var targetComponent = _this.itemRefs[index] && _this.itemRefs[index].current;
                targetComponent && targetComponent.focus();
            });
        };
        _this.getNavigationItemsSize = function () { return _this.props.panels.length; };
        _this.computeNewIndex = function (index) {
            var activeIndex = _this.state.activeIndex;
            var exclusive = _this.props.exclusive;
            if (!_this.isIndexActionable(index)) {
                return activeIndex;
            }
            if (exclusive)
                return index === activeIndex ? -1 : index;
            // check to see if index is in array, and remove it, if not then add it
            return _.includes(activeIndex, index)
                ? _.without(activeIndex, index)
                : tslib_1.__spreadArrays(activeIndex, [index]);
        };
        _this.handleTitleOverrides = function (predefinedProps) { return ({
            onClick: function (e, titleProps) {
                var index = titleProps.index;
                var activeIndex = _this.computeNewIndex(index);
                _this.setState({ activeIndex: activeIndex, focusedIndex: index });
                _.invoke(_this.props, 'onActiveIndexChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { activeIndex: activeIndex }));
                _.invoke(predefinedProps, 'onClick', e, titleProps);
                _.invoke(_this.props, 'onTitleClick', e, titleProps);
            },
            onFocus: function (e, titleProps) {
                _.invoke(predefinedProps, 'onFocus', e, titleProps);
                _this.setState({ focusedIndex: predefinedProps.index });
            },
        }); };
        _this.isIndexActive = function (index) {
            var exclusive = _this.props.exclusive;
            var activeIndex = _this.state.activeIndex;
            return exclusive ? activeIndex === index : _.includes(activeIndex, index);
        };
        /**
         * Checks if panel at index can be actioned upon. Used in the case of expanded accordion,
         * when at least a panel needs to stay active. Will return false if expanded prop is true,
         * index is active and either it's an exclusive accordion or if there are no other active
         * panels open besides this one.
         *
         * @param index - The index of the panel.
         * @returns If the panel can be set active/inactive.
         */
        _this.isIndexActionable = function (index) {
            if (!_this.isIndexActive(index)) {
                return true;
            }
            var activeIndex = _this.state.activeIndex;
            var _a = _this.props, expanded = _a.expanded, exclusive = _a.exclusive;
            return !expanded || (!exclusive && activeIndex.length > 1);
        };
        _this.renderPanels = function () {
            var children = [];
            var _a = _this.props, panels = _a.panels, renderPanelContent = _a.renderPanelContent, renderPanelTitle = _a.renderPanelTitle;
            var focusedIndex = _this.state.focusedIndex;
            _this.itemRefs = [];
            _this.focusHandler.syncFocusedIndex(focusedIndex);
            _.each(panels, function (panel, index) {
                var content = panel.content, title = panel.title;
                var active = _this.isIndexActive(index);
                var canBeCollapsed = _this.isIndexActionable(index);
                var contentRef = React.createRef();
                var titleId = title['id'] || "" + _this.defaultAccordionTitleId + index;
                var contentId = content['id'] || "" + _this.defaultAccordionContentId + index;
                _this.itemRefs[index] = contentRef;
                children.push(AccordionTitle_1.default.create(title, {
                    defaultProps: function () { return ({
                        className: Accordion.slotClassNames.title,
                        active: active,
                        index: index,
                        contentRef: contentRef,
                        canBeCollapsed: canBeCollapsed,
                        id: titleId,
                        accordionContentId: contentId,
                    }); },
                    overrideProps: _this.handleTitleOverrides,
                    render: renderPanelTitle,
                }));
                children.push(AccordionContent_1.default.create(content, {
                    defaultProps: function () { return ({
                        className: Accordion.slotClassNames.content,
                        active: active,
                        id: contentId,
                        accordionTitleId: titleId,
                    }); },
                    render: renderPanelContent,
                }));
            });
            return children;
        };
        _this.focusHandler = new FocusContainer_1.ContainerFocusHandler(_this.getNavigationItemsSize, _this.handleNavigationFocus, true);
        return _this;
    }
    Accordion.prototype.getInitialAutoControlledState = function (_a) {
        var expanded = _a.expanded, exclusive = _a.exclusive;
        var alwaysActiveIndex = expanded ? 0 : -1;
        return { activeIndex: exclusive ? alwaysActiveIndex : [alwaysActiveIndex] };
    };
    Accordion.prototype.renderComponent = function (_a) {
        var ElementType = _a.ElementType, classes = _a.classes, accessibility = _a.accessibility, unhandledProps = _a.unhandledProps;
        var children = this.props.children;
        return (React.createElement(ElementType, tslib_1.__assign({}, accessibility.attributes.root, utils_1.rtlTextContainer.getAttributes({ forElements: [children] }), unhandledProps, utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps), { className: classes.root }), utils_1.childrenExist(children) ? children : this.renderPanels()));
    };
    Accordion.displayName = 'Accordion';
    Accordion.className = 'ui-accordion';
    Accordion.slotClassNames = {
        content: Accordion.className + "__content",
        title: Accordion.className + "__title",
    };
    Accordion.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        content: false,
    })), { activeIndex: customPropTypes.every([
            customPropTypes.disallow(['children']),
            PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.number]),
        ]), defaultActiveIndex: customPropTypes.every([
            customPropTypes.disallow(['children']),
            PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.number]),
        ]), exclusive: PropTypes.bool, expanded: PropTypes.bool, onTitleClick: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.func]), onActiveIndexChange: PropTypes.func, panels: customPropTypes.every([
            customPropTypes.disallow(['children']),
            PropTypes.arrayOf(PropTypes.shape({
                content: customPropTypes.itemShorthand,
                title: customPropTypes.itemShorthand,
            })),
        ]), renderPanelTitle: PropTypes.func, renderPanelContent: PropTypes.func });
    Accordion.defaultProps = {
        accessibility: accessibility_1.accordionBehavior,
        as: 'dl',
    };
    Accordion.autoControlledProps = ['activeIndex'];
    Accordion.Title = AccordionTitle_1.default;
    Accordion.Content = AccordionContent_1.default;
    return Accordion;
}(utils_1.AutoControlledComponent));
/**
 * An Accordion represents stacked set of content sections, with action elements to toggle the display of these sections.
 *
 * @accessibility
 * Implements [ARIA Accordion](https://www.w3.org/TR/wai-aria-practices-1.1/#accordion) design pattern (keyboard navigation not yet supported).
 */
exports.default = types_1.withSafeTypeForAs(Accordion);
