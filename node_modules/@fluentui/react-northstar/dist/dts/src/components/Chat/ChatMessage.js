"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_context_selector_1 = require("@fluentui/react-context-selector");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var classnames_1 = require("classnames");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
// @ts-ignore
var react_fela_1 = require("react-fela");
var positioner_1 = require("../../utils/positioner");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
var Box_1 = require("../Box/Box");
var Label_1 = require("../Label/Label");
var Menu_1 = require("../Menu/Menu");
var Text_1 = require("../Text/Text");
var Reaction_1 = require("../Reaction/Reaction");
var chatItemContext_1 = require("./chatItemContext");
var ChatMessage = function (props) {
    var context = React.useContext(react_fela_1.ThemeContext);
    var _a = react_bindings_1.useTelemetry(ChatMessage.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var parentAttached = react_context_selector_1.useContextSelector(chatItemContext_1.ChatItemContext, function (v) { return v.attached; });
    var accessibility = props.accessibility, actionMenu = props.actionMenu, _b = props.attached, attached = _b === void 0 ? parentAttached : _b, author = props.author, badge = props.badge, badgePosition = props.badgePosition, children = props.children, className = props.className, content = props.content, design = props.design, mine = props.mine, positionActionMenu = props.positionActionMenu, reactionGroup = props.reactionGroup, reactionGroupPosition = props.reactionGroupPosition, timestamp = props.timestamp, styles = props.styles, variables = props.variables, overflow = props.unstable_overflow;
    var _c = React.useState(false), focused = _c[0], setFocused = _c[1];
    var _d = React.useState(null), messageNode = _d[0], setMessageNode = _d[1];
    var menuRef = React.useRef();
    var updateActionsMenuPosition = React.useRef(null);
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        actionHandlers: {
            // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
            // as navigation (only Tab key should work)
            preventDefault: function (event) {
                // preventDefault only if event coming from inside the message
                if (event.currentTarget !== event.target) {
                    event.preventDefault();
                }
            },
            focus: function (event) {
                if (messageNode) {
                    messageNode.focus();
                    event.stopPropagation();
                }
            },
        },
    });
    var _e = react_bindings_1.useStyles(ChatMessage.displayName, {
        className: ChatMessage.className,
        mapPropsToStyles: function () { return ({
            attached: attached,
            badgePosition: badgePosition,
            focused: focused,
            mine: mine,
            hasBadge: !!badge,
            hasReactionGroup: !!reactionGroup,
        }); },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }), classes = _e.classes, resolvedStyles = _e.styles;
    var handleFocus = function (e) {
        _.invoke(updateActionsMenuPosition, 'current');
        setFocused(true);
        _.invoke(props, 'onFocus', e, props);
    };
    var handleBlur = function (e) {
        // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
        // with keyboard the focused element will be changed and there is no way to use `:focus` selector
        var shouldPreserveFocusState = _.invoke(e, 'currentTarget.contains', e.relatedTarget);
        setFocused(shouldPreserveFocusState);
        _.invoke(props, 'onBlur', e, props);
    };
    var handleMouseEnter = function (e) {
        _.invoke(updateActionsMenuPosition, 'current');
        _.invoke(props, 'onMouseEnter', e, props);
    };
    var renderActionMenu = function () {
        var _a, _b;
        var actionMenuElement = Menu_1.default.create(actionMenu, {
            defaultProps: function () {
                var _a;
                return (_a = {},
                    _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = true,
                    _a.accessibility = accessibility_1.menuAsToolbarBehavior,
                    _a.className = ChatMessage.slotClassNames.actionMenu,
                    _a.styles = resolvedStyles.actionMenu,
                    _a);
            },
        });
        if (!actionMenuElement) {
            return actionMenuElement;
        }
        var messageRect = positionActionMenu && ((_a = messageNode) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect());
        var overflowPadding = { top: Math.round(((_b = messageRect) === null || _b === void 0 ? void 0 : _b.height) || 0) };
        return (React.createElement(positioner_1.Popper, tslib_1.__assign({ enabled: positionActionMenu, align: "end", modifiers: positionActionMenu && {
                // https://popper.js.org/popper-documentation.html#modifiers..flip.behavior
                // Forces to flip only in "top-*" positions
                flip: { behavior: ['top'] },
                preventOverflow: tslib_1.__assign({ escapeWithReference: false, 
                    // https://popper.js.org/popper-documentation.html#modifiers..preventOverflow.priority
                    // Forces to stop prevent overflow on bottom and bottom
                    priority: ['left', 'right'] }, (overflow && {
                    boundariesElement: 'scrollParent',
                    padding: overflowPadding,
                })),
            }, position: "above", positionFixed: overflow, targetRef: messageNode }, positioner_1.getPopperPropsFromShorthand(actionMenu)), function (_a) {
            var scheduleUpdate = _a.scheduleUpdate;
            updateActionsMenuPosition.current = scheduleUpdate;
            return React.createElement(react_component_ref_1.Ref, { innerRef: menuRef }, actionMenuElement);
        }));
    };
    var childrenPropExists = utils_1.childrenExist(children);
    var rootClasses = childrenPropExists ? classnames_1.default(classes.root, classes.content) : classes.root;
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(ChatMessage.handledProps, props);
    var badgeElement = Label_1.default.create(badge, {
        defaultProps: function () { return ({
            className: ChatMessage.slotClassNames.badge,
            styles: resolvedStyles.badge,
        }); },
    });
    var reactionGroupElement = Reaction_1.default.Group.create(reactionGroup, {
        defaultProps: function () { return ({
            className: ChatMessage.slotClassNames.reactionGroup,
            styles: resolvedStyles.reactionGroup,
        }); },
    });
    var actionMenuElement = renderActionMenu();
    var authorElement = Text_1.default.create(author, {
        defaultProps: function () { return ({
            size: 'small',
            styles: resolvedStyles.author,
            className: ChatMessage.slotClassNames.author,
        }); },
    });
    var timestampElement = Text_1.default.create(timestamp, {
        defaultProps: function () { return ({
            size: 'small',
            styles: resolvedStyles.timestamp,
            timestamp: true,
            className: ChatMessage.slotClassNames.timestamp,
        }); },
    });
    var messageContent = Box_1.default.create(content, {
        defaultProps: function () { return ({
            className: ChatMessage.slotClassNames.content,
            styles: resolvedStyles.content,
        }); },
    });
    var element = (React.createElement(react_component_ref_1.Ref, { innerRef: setMessageNode }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, tslib_1.__assign({}, getA11Props('root', tslib_1.__assign(tslib_1.__assign({ className: rootClasses, onBlur: handleBlur, onFocus: handleFocus, onMouseEnter: handleMouseEnter }, utils_1.rtlTextContainer.getAttributes({ forElements: [children] })), unhandledProps))), childrenPropExists ? (children) : (React.createElement(React.Fragment, null,
        actionMenuElement,
        badgePosition === 'start' && badgeElement,
        authorElement,
        timestampElement,
        reactionGroupPosition === 'start' && reactionGroupElement,
        messageContent,
        reactionGroupPosition === 'end' && reactionGroupElement,
        badgePosition === 'end' && badgeElement))))));
    setEnd();
    return element;
};
ChatMessage.className = 'ui-chat__message';
ChatMessage.displayName = 'ChatMessage';
ChatMessage.defaultProps = {
    accessibility: accessibility_1.chatMessageBehavior,
    badgePosition: 'end',
    positionActionMenu: true,
    reactionGroupPosition: 'start',
};
ChatMessage.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({ content: 'shorthand' })), { actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]), author: customPropTypes.itemShorthand, badge: customPropTypes.itemShorthand, badgePosition: PropTypes.oneOf(['start', 'end']), mine: PropTypes.bool, timestamp: customPropTypes.itemShorthand, onBlur: PropTypes.func, onFocus: PropTypes.func, onMouseEnter: PropTypes.func, positionActionMenu: PropTypes.bool, reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]), reactionGroupPosition: PropTypes.oneOf(['start', 'end']), unstable_overflow: PropTypes.bool });
ChatMessage.handledProps = Object.keys(ChatMessage.propTypes);
ChatMessage.create = utils_1.createShorthandFactory({ Component: ChatMessage, mappedProp: 'content' });
ChatMessage.slotClassNames = {
    actionMenu: ChatMessage.className + "__actions",
    author: ChatMessage.className + "__author",
    timestamp: ChatMessage.className + "__timestamp",
    badge: ChatMessage.className + "__badge",
    content: ChatMessage.className + "__content",
    reactionGroup: ChatMessage.className + "__reactions",
};
/**
 * A ChatMessage represents a single message in chat.
 */
exports.default = types_1.withSafeTypeForAs(ChatMessage);
