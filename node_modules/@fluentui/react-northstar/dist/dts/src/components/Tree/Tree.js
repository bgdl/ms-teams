"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var TreeItem_1 = require("./TreeItem");
var TreeTitle_1 = require("./TreeTitle");
var utils_1 = require("../../utils");
var types_1 = require("../../types");
var utils_2 = require("./utils");
var Tree = /** @class */ (function (_super) {
    tslib_1.__extends(Tree, _super);
    function Tree() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.treeRef = React.createRef();
        _this.itemsRef = new Map();
        _this.onFocusParent = function (parent) {
            var parentRef = _this.itemsRef.get(parent);
            if (!parentRef || !parentRef.current) {
                return;
            }
            parentRef.current.focus();
        };
        _this.onTitleClick = function (e, treeItemProps) {
            if (!utils_2.hasSubtree(treeItemProps)) {
                return;
            }
            var activeItemIds = _this.state.activeItemIds;
            var id = treeItemProps.id;
            var _a = _this.props, exclusive = _a.exclusive, items = _a.items;
            var siblings = utils_2.getSiblings(items, id);
            var activeItemIdIndex = activeItemIds.indexOf(id);
            if (activeItemIdIndex > -1) {
                activeItemIds = utils_2.removeItemAtIndex(activeItemIds, activeItemIdIndex);
            }
            else {
                if (exclusive) {
                    siblings.some(function (sibling) {
                        var activeSiblingIdIndex = activeItemIds.indexOf(sibling['id']);
                        if (activeSiblingIdIndex > -1) {
                            activeItemIds = utils_2.removeItemAtIndex(activeItemIds, activeSiblingIdIndex);
                            return true;
                        }
                        return false;
                    });
                }
                activeItemIds = tslib_1.__spreadArrays(activeItemIds, [id]);
            }
            _this.setActiveItemIds(e, activeItemIds);
        };
        _this.onFocusFirstChild = function (itemId) {
            var currentElement = _this.itemsRef.get(itemId);
            if (!currentElement || !currentElement.current) {
                return;
            }
            var elementToBeFocused = react_bindings_1.getNextElement(_this.treeRef.current, currentElement.current);
            if (!elementToBeFocused) {
                return;
            }
            elementToBeFocused.focus();
        };
        _this.onSiblingsExpand = function (e, treeItemProps) {
            var _a = _this.props, exclusive = _a.exclusive, items = _a.items;
            if (exclusive) {
                return;
            }
            var id = treeItemProps.id;
            var activeItemIds = _this.state.activeItemIds;
            var siblings = utils_2.getSiblings(items, id);
            siblings.forEach(function (sibling) {
                if (utils_2.hasSubtree(sibling) && !_this.isActiveItem(sibling['id'])) {
                    activeItemIds.push(sibling['id']);
                }
            });
            if (utils_2.hasSubtree(treeItemProps) && !_this.isActiveItem(id)) {
                activeItemIds.push(id);
            }
            _this.setActiveItemIds(e, activeItemIds);
        };
        _this.setActiveItemIds = function (e, activeItemIds) {
            _.invoke(_this.props, 'onActiveItemIdsChange', e, tslib_1.__assign(tslib_1.__assign({}, _this.props), { activeItemIds: activeItemIds }));
            _this.setState({
                activeItemIds: activeItemIds,
            });
        };
        _this.contextValue = {
            onFocusParent: _this.onFocusParent,
            onSiblingsExpand: _this.onSiblingsExpand,
            onFocusFirstChild: _this.onFocusFirstChild,
            onTitleClick: _this.onTitleClick,
        };
        _this.isActiveItem = function (id) {
            var activeItemIds = _this.state.activeItemIds;
            return activeItemIds.indexOf(id) > -1;
        };
        return _this;
    }
    Tree.getAutoControlledStateFromProps = function (nextProps, prevState) {
        var items = nextProps.items;
        var activeItemIds = nextProps.activeItemIds;
        if (!activeItemIds && items) {
            activeItemIds = prevState.activeItemIds;
            var expandedItemsGenerator_1 = function (items, acc) {
                if (acc === void 0) { acc = activeItemIds; }
                return _.reduce(items, function (acc, item) {
                    if (item['expanded'] && acc.indexOf(item['id']) === -1) {
                        acc.push(item['id']);
                    }
                    if (item['items']) {
                        return expandedItemsGenerator_1(item['items'], acc);
                    }
                    return acc;
                }, acc);
            };
            expandedItemsGenerator_1(items);
        }
        return {
            activeItemIds: activeItemIds,
        };
    };
    Tree.prototype.getInitialAutoControlledState = function () {
        return { activeItemIds: [] };
    };
    Tree.prototype.renderContent = function (accessibility) {
        var _this = this;
        var _a = this.props, items = _a.items, renderItemTitle = _a.renderItemTitle;
        if (!items)
            return null;
        var renderItems = function (items, level, parent) {
            if (level === void 0) { level = 1; }
            return items.reduce(function (renderedItems, item, index) {
                var itemId = item['id'];
                var isSubtree = utils_2.hasSubtree(item);
                var isSubtreeExpanded = isSubtree && _this.isActiveItem(itemId);
                if (!_this.itemsRef.has(itemId)) {
                    _this.itemsRef.set(itemId, React.createRef());
                }
                var renderedItem = TreeItem_1.default.create(item, {
                    defaultProps: function () { return ({
                        accessibility: accessibility.childBehaviors ? accessibility.childBehaviors.item : undefined,
                        className: Tree.slotClassNames.item,
                        expanded: isSubtreeExpanded,
                        renderItemTitle: renderItemTitle,
                        key: item['id'],
                        parent: parent,
                        level: level,
                        index: index + 1,
                        contentRef: _this.itemsRef.get(itemId),
                        treeSize: items.length,
                    }); },
                });
                return tslib_1.__spreadArrays(renderedItems, [
                    renderedItem
                ], (isSubtreeExpanded ? renderItems(item['items'], level + 1, itemId) : []));
            }, []);
        };
        return renderItems(items);
    };
    Tree.prototype.renderComponent = function (_a) {
        var ElementType = _a.ElementType, classes = _a.classes, accessibility = _a.accessibility, unhandledProps = _a.unhandledProps;
        var _b = this.props, children = _b.children, renderedItems = _b.renderedItems;
        return (React.createElement(utils_2.TreeContext.Provider, { value: this.contextValue },
            React.createElement(react_component_ref_1.Ref, { innerRef: this.treeRef },
                React.createElement(ElementType, tslib_1.__assign({ className: classes.root }, accessibility.attributes.root, utils_1.rtlTextContainer.getAttributes({ forElements: [children] }), unhandledProps, utils_1.applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps)), utils_1.childrenExist(children)
                    ? children
                    : renderedItems
                        ? renderedItems(this.renderContent(accessibility))
                        : this.renderContent(accessibility)))));
    };
    Tree.displayName = 'Tree';
    Tree.className = 'ui-tree';
    Tree.slotClassNames = {
        item: Tree.className + "__item",
    };
    Tree.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
        content: false,
    })), { activeItemIds: customPropTypes.collectionShorthand, defaultActiveItemIds: customPropTypes.collectionShorthand, exclusive: PropTypes.bool, items: customPropTypes.collectionShorthand, onActiveItemIdsChange: PropTypes.func, renderItemTitle: PropTypes.func, renderedItems: PropTypes.func });
    Tree.defaultProps = {
        as: 'div',
        accessibility: accessibility_1.treeBehavior,
    };
    Tree.autoControlledProps = ['activeItemIds'];
    Tree.Item = TreeItem_1.default;
    Tree.Title = TreeTitle_1.default;
    return Tree;
}(utils_1.AutoControlledComponent));
Tree.create = utils_1.createShorthandFactory({
    Component: Tree,
    mappedArrayProp: 'items',
});
/**
 * A Tree displays data organised in tree hierarchy.
 *
 * @accessibility
 * Implements [ARIA TreeView](https://www.w3.org/TR/wai-aria-practices-1.1/#TreeView) design pattern.
 * @accessibilityIssues
 * [Treeview - JAWS doesn't narrate position for each tree item](https://github.com/FreedomScientific/VFO-standards-support/issues/338)
 * [Aria compliant trees are read as empty tables](https://bugs.chromium.org/p/chromium/issues/detail?id=1048770)
 */
exports.default = types_1.withSafeTypeForAs(Tree);
