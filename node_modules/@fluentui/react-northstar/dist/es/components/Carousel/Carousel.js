import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _invoke from "lodash/invoke";
import _debounce from "lodash/debounce";
import * as customPropTypes from '@fluentui/react-proptypes';
import { carouselBehavior } from '@fluentui/accessibility';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import cx from 'classnames';
import { Ref } from '@fluentui/react-component-ref';
import Animation from '../Animation/Animation';
import { createShorthandFactory, commonPropTypes, applyAccessibilityKeyHandlers, childrenExist, getOrGenerateIdFromShorthand, AutoControlledComponent, isFromKeyboard } from '../../utils';
import { withSafeTypeForAs } from '../../types';
import CarouselItem from './CarouselItem';
import Text from '../Text/Text';
import CarouselNavigation from './CarouselNavigation';
import CarouselNavigationItem from './CarouselNavigationItem';
import CarouselPaddle from './CarouselPaddle';

var Carousel =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Carousel, _AutoControlledCompon);

  function Carousel() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Carousel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Carousel)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "actionHandlers", {
      showNextSlideByKeyboardNavigation: function showNextSlideByKeyboardNavigation(e) {
        e.preventDefault();

        _this.showNextSlide(e, true);
      },
      showPreviousSlideByKeyboardNavigation: function showPreviousSlideByKeyboardNavigation(e) {
        e.preventDefault();

        _this.showPreviousSlide(e, true);
      },
      showNextSlideByPaddlePress: function showNextSlideByPaddlePress(e) {
        e.preventDefault();

        _this.showNextSlide(e, false);

        _this.handleNextPaddleFocus();
      },
      showPreviousSlideByPaddlePress: function showPreviousSlideByPaddlePress(e) {
        e.preventDefault();

        _this.showPreviousSlide(e, false);

        _this.handlePreviousPaddleFocus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "itemRefs", []);

    _defineProperty(_assertThisInitialized(_this), "paddleNextRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "paddlePreviousRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "focusItemAtIndex", _debounce(function (index) {
      _this.itemRefs[index].current.focus();
    }, 400));

    _defineProperty(_assertThisInitialized(_this), "overrideItemProps", function (predefinedProps) {
      return {
        onFocus: function onFocus(e, itemProps) {
          _this.setState({
            shouldFocusContainer: e.currentTarget === e.target,
            isFromKeyboard: isFromKeyboard()
          });

          _invoke(predefinedProps, 'onFocus', e, itemProps);
        },
        onBlur: function onBlur(e, itemProps) {
          _this.setState({
            shouldFocusContainer: e.currentTarget.contains(e.relatedTarget),
            isFromKeyboard: false
          });

          _invoke(predefinedProps, 'onBlur', e, itemProps);
        }
      };
    });

    _defineProperty(_assertThisInitialized(_this), "renderContent", function (accessibility, classes, unhandledProps) {
      var _this$props = _this.props,
          getItemPositionText = _this$props.getItemPositionText,
          items = _this$props.items,
          circular = _this$props.circular;
      var _this$state = _this.state,
          activeIndex = _this$state.activeIndex,
          itemIds = _this$state.itemIds,
          prevActiveIndex = _this$state.prevActiveIndex;
      _this.itemRefs = [];
      return React.createElement("div", _extends({
        className: classes.itemsContainerWrapper
      }, accessibility.attributes.itemsContainerWrapper), React.createElement("div", _extends({
        className: cx(Carousel.slotClassNames.itemsContainer, classes.itemsContainer)
      }, accessibility.attributes.itemsContainer, applyAccessibilityKeyHandlers(accessibility.keyHandlers.itemsContainer, unhandledProps)), items && items.map(function (item, index) {
        var itemRef = React.createRef();

        _this.itemRefs.push(itemRef);

        var active = activeIndex === index;
        var slideToNext = prevActiveIndex < activeIndex;
        var initialMounting = prevActiveIndex === -1;

        if (circular && prevActiveIndex === items.length - 1 && activeIndex === 0) {
          slideToNext = true;
        } else if (circular && prevActiveIndex === 0 && activeIndex === items.length - 1) {
          slideToNext = false;
        }

        return React.createElement(Animation, {
          key: item['key'] || index,
          mountOnEnter: true,
          unmountOnExit: true,
          visible: active,
          name: initialMounting ? '' : active ? slideToNext ? 'carousel-slide-to-next-enter' : 'carousel-slide-to-previous-enter' : slideToNext ? 'carousel-slide-to-next-exit' : 'carousel-slide-to-previous-exit'
        }, React.createElement(Ref, {
          innerRef: itemRef
        }, CarouselItem.create(item, {
          defaultProps: function defaultProps() {
            return Object.assign({
              active: active,
              id: itemIds[index],
              navigation: !!_this.props.navigation
            }, getItemPositionText && {
              itemPositionText: getItemPositionText(index, items.length)
            });
          },
          overrideProps: _this.overrideItemProps
        })));
      })));
    });

    _defineProperty(_assertThisInitialized(_this), "handleNextPaddleFocus", function () {
      // if 'next' paddle will disappear, will focus 'previous' one.
      if (!_this.props.navigation && _this.state.activeIndex >= _this.props.items.length - 2 && !_this.props.circular) {
        _this.paddlePreviousRef.current.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handlePreviousPaddleFocus", function () {
      // if 'previous' paddle will disappear, will focus 'next' one.
      if (!_this.props.navigation && _this.state.activeIndex <= 1 && !_this.props.circular) {
        _this.paddleNextRef.current.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "showPreviousSlide", function (e, focusItem) {
      _this.setActiveIndex(e, _this.state.activeIndex - 1, focusItem);
    });

    _defineProperty(_assertThisInitialized(_this), "showNextSlide", function (e, focusItem) {
      _this.setActiveIndex(e, _this.state.activeIndex + 1, focusItem);
    });

    _defineProperty(_assertThisInitialized(_this), "handlePaddleOverrides", function (predefinedProps, paddleName) {
      return {
        onClick: function onClick(e, paddleProps) {
          _invoke(predefinedProps, 'onClick', e, paddleProps);

          if (paddleName === 'paddleNext') {
            _this.showNextSlide(e, false);

            _this.handleNextPaddleFocus();
          } else if (paddleName === 'paddlePrevious') {
            _this.showPreviousSlide(e, false);

            _this.handlePreviousPaddleFocus();
          }
        },
        onBlur: function onBlur(e, paddleProps) {
          if (e.relatedTarget !== _this.paddleNextRef.current) {
            _this.setState({
              ariaLiveOn: false
            });
          }
        },
        onFocus: function onFocus(e, paddleProps) {
          _invoke(predefinedProps, 'onFocus', e, paddleProps);

          _this.setState({
            ariaLiveOn: true
          });
        }
      };
    });

    _defineProperty(_assertThisInitialized(_this), "renderPaddles", function (accessibility) {
      var _this$props2 = _this.props,
          paddlePrevious = _this$props2.paddlePrevious,
          paddleNext = _this$props2.paddleNext,
          items = _this$props2.items,
          circular = _this$props2.circular;
      var activeIndex = _this.state.activeIndex;
      return React.createElement(React.Fragment, null, React.createElement(Ref, {
        innerRef: _this.paddlePreviousRef
      }, CarouselPaddle.create(paddlePrevious, {
        defaultProps: function defaultProps() {
          return Object.assign({
            className: Carousel.slotClassNames.paddlePrevious,
            previous: true,
            hidden: items !== undefined && !circular && activeIndex === 0
          }, accessibility.attributes.paddlePrevious, {}, applyAccessibilityKeyHandlers(accessibility.keyHandlers.paddlePrevious, paddlePrevious));
        },
        overrideProps: function overrideProps(predefinedProps) {
          return _this.handlePaddleOverrides(predefinedProps, 'paddlePrevious');
        }
      })), React.createElement(Ref, {
        innerRef: _this.paddleNextRef
      }, CarouselPaddle.create(paddleNext, {
        defaultProps: function defaultProps() {
          return Object.assign({
            className: Carousel.slotClassNames.paddleNext,
            next: true,
            hidden: items !== undefined && !circular && activeIndex === items.length - 1
          }, accessibility.attributes.paddleNext, {}, applyAccessibilityKeyHandlers(accessibility.keyHandlers.paddleNext, paddleNext));
        },
        overrideProps: function overrideProps(predefinedProps) {
          return _this.handlePaddleOverrides(predefinedProps, 'paddleNext');
        }
      })));
    });

    _defineProperty(_assertThisInitialized(_this), "renderNavigation", function () {
      var _this$props3 = _this.props,
          getItemPositionText = _this$props3.getItemPositionText,
          navigation = _this$props3.navigation,
          items = _this$props3.items;

      if (!items || !items.length) {
        return null;
      }

      var activeIndex = _this.state.activeIndex;
      return navigation ? CarouselNavigation.create(navigation, {
        defaultProps: function defaultProps() {
          return {
            className: Carousel.slotClassNames.navigation,
            iconOnly: true,
            activeIndex: activeIndex
          };
        },
        overrideProps: function overrideProps(predefinedProps) {
          return {
            onItemClick: function onItemClick(e, itemProps) {
              var index = itemProps.index;

              _this.setActiveIndex(e, index, true);

              _invoke(predefinedProps, 'onClick', e, itemProps);
            }
          };
        }
      }) : React.createElement(Text, {
        "aria-hidden": "true",
        className: Carousel.slotClassNames.pagination,
        content: getItemPositionText(activeIndex, items.length)
      });
    });

    return _this;
  }

  _createClass(Carousel, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.focusItemAtIndex.cancel();
    }
  }, {
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState() {
      return {
        activeIndex: 0,
        prevActiveIndex: -1,
        ariaLiveOn: false,
        itemIds: [],
        shouldFocusContainer: false,
        isFromKeyboard: false
      };
    }
  }, {
    key: "setActiveIndex",
    value: function setActiveIndex(e, index, focusItem) {
      var _this$props4 = this.props,
          circular = _this$props4.circular,
          items = _this$props4.items;
      var lastItemIndex = items.length - 1;
      var activeIndex = index;

      if (index < 0) {
        if (!circular) {
          return;
        }

        activeIndex = lastItemIndex;
      }

      if (index > lastItemIndex) {
        if (!circular) {
          return;
        }

        activeIndex = 0;
      }

      this.setState({
        prevActiveIndex: this.state.activeIndex,
        activeIndex: activeIndex
      });

      _invoke(this.props, 'onActiveIndexChange', e, this.props);

      if (focusItem) {
        this.focusItemAtIndex(activeIndex);
      }
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref) {
      var ElementType = _ref.ElementType,
          classes = _ref.classes,
          accessibility = _ref.accessibility,
          unhandledProps = _ref.unhandledProps;
      var children = this.props.children;
      return React.createElement(ElementType, _extends({
        className: classes.root
      }, accessibility.attributes.root, unhandledProps, applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps)), childrenExist(children) ? children : React.createElement(React.Fragment, null, this.renderContent(accessibility, classes, unhandledProps), this.renderPaddles(accessibility), this.renderNavigation()));
    }
  }], [{
    key: "getAutoControlledStateFromProps",
    value: function getAutoControlledStateFromProps(props, state) {
      var items = props.items;
      var itemIds = state.itemIds;

      if (!items) {
        return null;
      }

      return {
        itemIds: items.map(function (item, index) {
          return getOrGenerateIdFromShorthand('carousel-item-', item, itemIds[index]);
        })
      };
    }
  }]);

  return Carousel;
}(AutoControlledComponent);

_defineProperty(Carousel, "create", void 0);

_defineProperty(Carousel, "displayName", 'Carousel');

_defineProperty(Carousel, "className", 'ui-carousel');

_defineProperty(Carousel, "slotClassNames", {
  itemsContainer: "".concat(Carousel.className, "__itemscontainer"),
  paddleNext: "".concat(Carousel.className, "__paddlenext"),
  paddlePrevious: "".concat(Carousel.className, "__paddleprevious"),
  pagination: "".concat(Carousel.className, "__pagination"),
  navigation: "".concat(Carousel.className, "__navigation")
});

_defineProperty(Carousel, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  content: false
}), {
  activeIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  ariaRoleDescription: PropTypes.string,
  ariaLabel: PropTypes.string,
  circular: PropTypes.bool,
  defaultActiveIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  getItemPositionText: PropTypes.func,
  items: customPropTypes.collectionShorthand,
  navigation: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  navigationPosition: PropTypes.string,
  onActiveIndexChange: PropTypes.func,
  paddleNext: customPropTypes.itemShorthand,
  paddlesPosition: PropTypes.string,
  paddlePrevious: customPropTypes.itemShorthand
}));

_defineProperty(Carousel, "autoControlledProps", ['activeIndex']);

_defineProperty(Carousel, "defaultProps", {
  accessibility: carouselBehavior,
  paddlePrevious: {},
  paddleNext: {}
});

_defineProperty(Carousel, "Item", CarouselItem);

_defineProperty(Carousel, "Navigation", CarouselNavigation);

_defineProperty(Carousel, "NavigationItem", CarouselNavigationItem);

_defineProperty(Carousel, "Paddle", CarouselPaddle);

Carousel.create = createShorthandFactory({
  Component: Carousel,
  mappedArrayProp: 'items'
});
/**
 * A Carousel displays data organised as a gallery.
 *
 * @accessibility
 * Implements [ARIA Carousel](https://www.w3.org/WAI/tutorials/carousels/structure/) design pattern.
 * @accessibilityIssues
 * [VoiceOver doens't narrate label referenced by aria-labelledby attribute, when role is "tabpanel"](https://bugs.chromium.org/p/chromium/issues/detail?id=1040924)
 */

export default withSafeTypeForAs(Carousel);
//# sourceMappingURL=Carousel.js.map
