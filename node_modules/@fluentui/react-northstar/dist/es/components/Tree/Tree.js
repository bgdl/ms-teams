import _extends from "@babel/runtime/helpers/esm/extends";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _invoke from "lodash/invoke";
import _reduce from "lodash/reduce";
import { treeBehavior } from '@fluentui/accessibility';
import { getNextElement } from '@fluentui/react-bindings';
import * as customPropTypes from '@fluentui/react-proptypes';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { Ref } from '@fluentui/react-component-ref';
import TreeItem from './TreeItem';
import TreeTitle from './TreeTitle';
import { childrenExist, commonPropTypes, createShorthandFactory, rtlTextContainer, applyAccessibilityKeyHandlers, AutoControlledComponent } from '../../utils';
import { withSafeTypeForAs } from '../../types';
import { hasSubtree, removeItemAtIndex, getSiblings, TreeContext } from './utils';

var Tree =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Tree, _AutoControlledCompon);

  function Tree() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Tree);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Tree)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "treeRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "itemsRef", new Map());

    _defineProperty(_assertThisInitialized(_this), "onFocusParent", function (parent) {
      var parentRef = _this.itemsRef.get(parent);

      if (!parentRef || !parentRef.current) {
        return;
      }

      parentRef.current.focus();
    });

    _defineProperty(_assertThisInitialized(_this), "onTitleClick", function (e, treeItemProps) {
      if (!hasSubtree(treeItemProps)) {
        return;
      }

      var activeItemIds = _this.state.activeItemIds;
      var id = treeItemProps.id;
      var _this$props = _this.props,
          exclusive = _this$props.exclusive,
          items = _this$props.items;
      var siblings = getSiblings(items, id);
      var activeItemIdIndex = activeItemIds.indexOf(id);

      if (activeItemIdIndex > -1) {
        activeItemIds = removeItemAtIndex(activeItemIds, activeItemIdIndex);
      } else {
        if (exclusive) {
          siblings.some(function (sibling) {
            var activeSiblingIdIndex = activeItemIds.indexOf(sibling['id']);

            if (activeSiblingIdIndex > -1) {
              activeItemIds = removeItemAtIndex(activeItemIds, activeSiblingIdIndex);
              return true;
            }

            return false;
          });
        }

        activeItemIds = [].concat(_toConsumableArray(activeItemIds), [id]);
      }

      _this.setActiveItemIds(e, activeItemIds);
    });

    _defineProperty(_assertThisInitialized(_this), "onFocusFirstChild", function (itemId) {
      var currentElement = _this.itemsRef.get(itemId);

      if (!currentElement || !currentElement.current) {
        return;
      }

      var elementToBeFocused = getNextElement(_this.treeRef.current, currentElement.current);

      if (!elementToBeFocused) {
        return;
      }

      elementToBeFocused.focus();
    });

    _defineProperty(_assertThisInitialized(_this), "onSiblingsExpand", function (e, treeItemProps) {
      var _this$props2 = _this.props,
          exclusive = _this$props2.exclusive,
          items = _this$props2.items;

      if (exclusive) {
        return;
      }

      var id = treeItemProps.id;
      var activeItemIds = _this.state.activeItemIds;
      var siblings = getSiblings(items, id);
      siblings.forEach(function (sibling) {
        if (hasSubtree(sibling) && !_this.isActiveItem(sibling['id'])) {
          activeItemIds.push(sibling['id']);
        }
      });

      if (hasSubtree(treeItemProps) && !_this.isActiveItem(id)) {
        activeItemIds.push(id);
      }

      _this.setActiveItemIds(e, activeItemIds);
    });

    _defineProperty(_assertThisInitialized(_this), "setActiveItemIds", function (e, activeItemIds) {
      _invoke(_this.props, 'onActiveItemIdsChange', e, Object.assign({}, _this.props, {
        activeItemIds: activeItemIds
      }));

      _this.setState({
        activeItemIds: activeItemIds
      });
    });

    _defineProperty(_assertThisInitialized(_this), "contextValue", {
      onFocusParent: _this.onFocusParent,
      onSiblingsExpand: _this.onSiblingsExpand,
      onFocusFirstChild: _this.onFocusFirstChild,
      onTitleClick: _this.onTitleClick
    });

    _defineProperty(_assertThisInitialized(_this), "isActiveItem", function (id) {
      var activeItemIds = _this.state.activeItemIds;
      return activeItemIds.indexOf(id) > -1;
    });

    return _this;
  }

  _createClass(Tree, [{
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState() {
      return {
        activeItemIds: []
      };
    }
  }, {
    key: "renderContent",
    value: function renderContent(accessibility) {
      var _this2 = this;

      var _this$props3 = this.props,
          items = _this$props3.items,
          renderItemTitle = _this$props3.renderItemTitle;
      if (!items) return null;

      var renderItems = function renderItems(items) {
        var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var parent = arguments.length > 2 ? arguments[2] : undefined;
        return items.reduce(function (renderedItems, item, index) {
          var itemId = item['id'];
          var isSubtree = hasSubtree(item);

          var isSubtreeExpanded = isSubtree && _this2.isActiveItem(itemId);

          if (!_this2.itemsRef.has(itemId)) {
            _this2.itemsRef.set(itemId, React.createRef());
          }

          var renderedItem = TreeItem.create(item, {
            defaultProps: function defaultProps() {
              return {
                accessibility: accessibility.childBehaviors ? accessibility.childBehaviors.item : undefined,
                className: Tree.slotClassNames.item,
                expanded: isSubtreeExpanded,
                renderItemTitle: renderItemTitle,
                key: item['id'],
                parent: parent,
                level: level,
                index: index + 1,
                // Used for aria-posinset and it's 1-based.
                contentRef: _this2.itemsRef.get(itemId),
                treeSize: items.length
              };
            }
          });
          return [].concat(_toConsumableArray(renderedItems), [renderedItem], _toConsumableArray(isSubtreeExpanded ? renderItems(item['items'], level + 1, itemId) : []));
        }, []);
      };

      return renderItems(items);
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref) {
      var ElementType = _ref.ElementType,
          classes = _ref.classes,
          accessibility = _ref.accessibility,
          unhandledProps = _ref.unhandledProps;
      var _this$props4 = this.props,
          children = _this$props4.children,
          renderedItems = _this$props4.renderedItems;
      return React.createElement(TreeContext.Provider, {
        value: this.contextValue
      }, React.createElement(Ref, {
        innerRef: this.treeRef
      }, React.createElement(ElementType, _extends({
        className: classes.root
      }, accessibility.attributes.root, rtlTextContainer.getAttributes({
        forElements: [children]
      }), unhandledProps, applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps)), childrenExist(children) ? children : renderedItems ? renderedItems(this.renderContent(accessibility)) : this.renderContent(accessibility))));
    }
  }], [{
    key: "getAutoControlledStateFromProps",
    value: function getAutoControlledStateFromProps(nextProps, prevState) {
      var items = nextProps.items;
      var activeItemIds = nextProps.activeItemIds;

      if (!activeItemIds && items) {
        activeItemIds = prevState.activeItemIds;

        var expandedItemsGenerator = function expandedItemsGenerator(items) {
          var acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : activeItemIds;
          return _reduce(items, function (acc, item) {
            if (item['expanded'] && acc.indexOf(item['id']) === -1) {
              acc.push(item['id']);
            }

            if (item['items']) {
              return expandedItemsGenerator(item['items'], acc);
            }

            return acc;
          }, acc);
        };

        expandedItemsGenerator(items);
      }

      return {
        activeItemIds: activeItemIds
      };
    }
  }]);

  return Tree;
}(AutoControlledComponent);

_defineProperty(Tree, "create", void 0);

_defineProperty(Tree, "displayName", 'Tree');

_defineProperty(Tree, "className", 'ui-tree');

_defineProperty(Tree, "slotClassNames", {
  item: "".concat(Tree.className, "__item")
});

_defineProperty(Tree, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  content: false
}), {
  activeItemIds: customPropTypes.collectionShorthand,
  defaultActiveItemIds: customPropTypes.collectionShorthand,
  exclusive: PropTypes.bool,
  items: customPropTypes.collectionShorthand,
  onActiveItemIdsChange: PropTypes.func,
  renderItemTitle: PropTypes.func,
  renderedItems: PropTypes.func
}));

_defineProperty(Tree, "defaultProps", {
  as: 'div',
  accessibility: treeBehavior
});

_defineProperty(Tree, "autoControlledProps", ['activeItemIds']);

_defineProperty(Tree, "Item", TreeItem);

_defineProperty(Tree, "Title", TreeTitle);

Tree.create = createShorthandFactory({
  Component: Tree,
  mappedArrayProp: 'items'
});
/**
 * A Tree displays data organised in tree hierarchy.
 *
 * @accessibility
 * Implements [ARIA TreeView](https://www.w3.org/TR/wai-aria-practices-1.1/#TreeView) design pattern.
 * @accessibilityIssues
 * [Treeview - JAWS doesn't narrate position for each tree item](https://github.com/FreedomScientific/VFO-standards-support/issues/338)
 * [Aria compliant trees are read as empty tables](https://bugs.chromium.org/p/chromium/issues/detail?id=1048770)
 */

export default withSafeTypeForAs(Tree);
//# sourceMappingURL=Tree.js.map
