{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _debounce from \"lodash/debounce\";\nimport _invoke from \"lodash/invoke\";\nimport _forEachRight from \"lodash/forEachRight\";\nimport _get from \"lodash/get\";\nimport _map from \"lodash/map\";\nimport { toolbarBehavior, toggleButtonBehavior, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport * as React from 'react';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as PropTypes from 'prop-types';\nimport { Ref } from '@fluentui/react-component-ref';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { getFirstFocusable } from '@fluentui/react-bindings';\nimport { childrenExist, createShorthandFactory, UIComponent, commonPropTypes } from '../../utils';\nimport { withSafeTypeForAs } from '../../types';\nimport ToolbarCustomItem from './ToolbarCustomItem';\nimport ToolbarDivider from './ToolbarDivider';\nimport ToolbarItem from './ToolbarItem';\nimport ToolbarMenu from './ToolbarMenu';\nimport ToolbarMenuDivider from './ToolbarMenuDivider';\nimport ToolbarMenuItem from './ToolbarMenuItem';\nimport ToolbarMenuRadioGroup from './ToolbarMenuRadioGroup';\nimport ToolbarRadioGroup from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\nvar WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\n\nvar Toolbar = /*#__PURE__*/function (_UIComponent) {\n  _inherits(Toolbar, _UIComponent);\n\n  function Toolbar() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Toolbar);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Toolbar)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"overflowContainerRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"overflowItemRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"offsetMeasureRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"containerRef\", React.createRef());\n\n    _defineProperty(_assertThisInitialized(_this), \"lastVisibleItemIndex\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"animationFrameId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"rtl\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"hideOverflowItems\", function () {\n      var $overflowContainer = _this.overflowContainerRef.current;\n      var $overflowItem = _this.overflowItemRef.current;\n      var $offsetMeasure = _this.offsetMeasureRef.current;\n\n      if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n        return;\n      } // workaround: when resizing window with popup opened the container contents scroll for some reason\n\n\n      if (_this.rtl) {\n        $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n      } else {\n        $overflowContainer.scrollTo(0, 0);\n      }\n\n      var $items = $overflowContainer.children;\n      var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n      var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n      var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect(); // Absolute positioning offset\n      // Overflow menu is absolutely positioned relative to root slot\n      // If there is padding set on the root slot boundingClientRect computations use inner content box,\n      // but absolute position is relative to root slot's PADDING box.\n      // We compute absolute positioning offset\n      // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n      // TODO: replace by getComputedStyle('padding')\n\n      var absolutePositioningOffset = {\n        horizontal: _this.rtl ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n        vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top\n      };\n      var isOverflowing = false;\n      var $lastVisibleItem;\n      var lastVisibleItemRect; // check all items from the last one back\n\n      _forEachRight($items, function ($item, i) {\n        if ($item === $overflowItem) {\n          return true;\n        }\n\n        var itemBoundingRect = $item.getBoundingClientRect(); // if the item is out of the crop rectangle, hide it\n\n        if (_this.isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n          isOverflowing = true; // console.log('Overflow', i, {\n          //   item: [itemBoundingRect.left, itemBoundingRect.right],\n          //   crop: [\n          //     overflowContainerBoundingRect.left,\n          //     overflowContainerBoundingRect.right,\n          //     overflowContainerBoundingRect.width,\n          //   ],\n          //   container: $overflowContainer,\n          // })\n\n          _this.hide($item);\n\n          return true;\n        } // if there is an overflow, check collision of remaining items with eventual overflow position\n\n\n        if (isOverflowing && !$lastVisibleItem && _this.wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {\n          _this.hide($item);\n\n          return true;\n        } // Remember the last visible item\n\n\n        if (!$lastVisibleItem) {\n          $lastVisibleItem = $item;\n          lastVisibleItemRect = itemBoundingRect;\n          _this.lastVisibleItemIndex = i;\n        }\n\n        return _this.show($item); // exit the loop when first visible item is found\n      }); // if there is an overflow,  position and show overflow item, otherwise hide it\n\n\n      if (isOverflowing || _this.props.overflowOpen) {\n        $overflowItem.style.position = 'absolute';\n\n        _this.setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);\n\n        _this.show($overflowItem);\n      } else {\n        _this.lastVisibleItemIndex = _this.props.items.length - 1;\n\n        _this.hide($overflowItem);\n      }\n\n      _invoke(_this.props, 'onOverflow', _this.lastVisibleItemIndex + 1);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getOverflowItems\", function () {\n      // console.log('getOverflowItems()', this.props.items.slice(this.lastVisibleItemIndex + 1))\n      return _this.props.getOverflowItems ? _this.props.getOverflowItems(_this.lastVisibleItemIndex + 1) : _this.props.items.slice(_this.lastVisibleItemIndex + 1);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getVisibleItems\", function () {\n      // console.log('allItems()', this.props.items)\n      var end = _this.props.overflowOpen ? _this.lastVisibleItemIndex + 1 : _this.props.items.length; // console.log('getVisibleItems()', this.props.items.slice(0, end))\n\n      return _this.props.items.slice(0, end);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleWindowResize\", _debounce(function (e) {\n      _this.hideOverflowItems();\n\n      if (_this.props.overflowOpen) {\n        _invoke(_this.props, 'onOverflowOpenChange', e, Object.assign({}, _this.props, {\n          overflowOpen: false\n        }));\n      }\n    }, 16));\n\n    return _this;\n  }\n\n  _createClass(Toolbar, [{\n    key: \"renderItems\",\n    value: function renderItems(items) {\n      return _map(items, function (item) {\n        var kind = _get(item, 'kind', 'item');\n\n        switch (kind) {\n          case 'divider':\n            return ToolbarDivider.create(item);\n\n          case 'group':\n            return ToolbarRadioGroup.create(item);\n\n          case 'toggle':\n            return ToolbarItem.create(item, {\n              defaultProps: function defaultProps() {\n                return {\n                  accessibility: toggleButtonBehavior\n                };\n              }\n            });\n\n          case 'custom':\n            return ToolbarCustomItem.create(item);\n\n          default:\n            return ToolbarItem.create(item);\n        }\n      });\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(el) {\n      if (el.style.visibility === 'hidden') {\n        return;\n      }\n\n      if (this.context.target.activeElement === el || el.contains(this.context.target.activeElement)) {\n        if (this.containerRef.current) {\n          var firstFocusableItem = getFirstFocusable(this.containerRef.current, this.containerRef.current.firstElementChild);\n\n          if (firstFocusableItem) {\n            firstFocusableItem.focus();\n          }\n        }\n      }\n\n      el.style.visibility = 'hidden';\n      var wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n\n      if (wasFocusable) {\n        el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      }\n\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n    }\n  }, {\n    key: \"show\",\n    value: function show(el) {\n      if (el.style.visibility !== 'hidden') {\n        return false;\n      }\n\n      el.style.visibility = null;\n      var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n\n      if (wasFocusable) {\n        el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n        el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n      } else {\n        el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n      }\n\n      return true;\n    }\n    /**\n     * Checks if `item` overflows a `container`.\n     * TODO: check and fix all margin combination\n     */\n\n  }, {\n    key: \"isItemOverflowing\",\n    value: function isItemOverflowing(itemBoundingRect, containerBoundingRect) {\n      return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n    }\n    /**\n     * Checks if `item` would collide with eventual position of `overflowItem`.\n     */\n\n  }, {\n    key: \"wouldItemCollide\",\n    value: function wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {\n      var actualWindow = this.context.target.defaultView;\n      var wouldCollide;\n\n      if (this.rtl) {\n        var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n        wouldCollide = itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left; // console.log('Collision [RTL]', {\n        //   wouldCollide,\n        //   'itemBoundingRect.left': itemBoundingRect.left,\n        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n        //   itemRightMargin: itemLeftMargin,\n        //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n        //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n        // })\n      } else {\n        var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n        wouldCollide = itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right; // console.log('Collision', {\n        //   wouldCollide,\n        //   'itemBoundingRect.right': itemBoundingRect.right,\n        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n        //   itemRightMargin,\n        //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n        //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n        // })\n      }\n\n      return wouldCollide;\n    }\n    /**\n     * Positions overflowItem next to lastVisible item\n     * TODO: consider overflowItem margin\n     */\n\n  }, {\n    key: \"setOverflowPosition\",\n    value: function setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {\n      var actualWindow = this.context.target.defaultView;\n\n      if ($lastVisibleItem) {\n        if (this.rtl) {\n          var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n          $overflowItem.style.right = \"\".concat(containerBoundingRect.right - lastVisibleItemRect.left + lastVisibleItemMarginLeft + absolutePositioningOffset.horizontal, \"px\");\n        } else {\n          var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n          $overflowItem.style.left = \"\".concat(lastVisibleItemRect.right - containerBoundingRect.left + lastVisibleItemRightMargin + absolutePositioningOffset.horizontal, \"px\");\n        }\n      } else {\n        // there is no last visible item -> position the overflow as the first item\n        this.lastVisibleItemIndex = -1;\n\n        if (this.rtl) {\n          $overflowItem.style.right = \"\".concat(absolutePositioningOffset.horizontal, \"px\");\n        } else {\n          $overflowItem.style.left = \"\".concat(absolutePositioningOffset.horizontal, \"px\");\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.afterComponentRendered();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.afterComponentRendered();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.animationFrameId !== undefined) {\n        this.context.target.defaultView.cancelAnimationFrame(this.animationFrameId);\n        this.animationFrameId = undefined;\n      }\n    }\n  }, {\n    key: \"afterComponentRendered\",\n    value: function afterComponentRendered() {\n      var _this2 = this;\n\n      var actualWindow = this.context.target.defaultView;\n\n      if (this.animationFrameId !== undefined) {\n        actualWindow.cancelAnimationFrame(this.animationFrameId);\n      } // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n\n\n      this.animationFrameId = actualWindow.requestAnimationFrame(function () {\n        _this2.hideOverflowItems();\n      });\n    }\n  }, {\n    key: \"renderOverflowItem\",\n    value: function renderOverflowItem(overflowItem) {\n      var _this3 = this;\n\n      return React.createElement(Ref, {\n        innerRef: this.overflowItemRef\n      }, ToolbarItem.create(overflowItem, {\n        defaultProps: function defaultProps() {\n          return {\n            // TODO: ups\n            icon: React.createElement(MoreIcon, {\n              outline: true\n            })\n          };\n        },\n        overrideProps: {\n          menu: this.props.overflowOpen ? this.getOverflowItems() : [],\n          menuOpen: this.props.overflowOpen,\n          onMenuOpenChange: function onMenuOpenChange(e, _ref) {\n            var menuOpen = _ref.menuOpen;\n\n            _invoke(_this3.props, 'onOverflowOpenChange', e, Object.assign({}, _this3.props, {\n              overflowOpen: menuOpen\n            }));\n          }\n        }\n      }));\n    }\n  }, {\n    key: \"renderComponent\",\n    value: function renderComponent(_ref2) {\n      var accessibility = _ref2.accessibility,\n          ElementType = _ref2.ElementType,\n          classes = _ref2.classes,\n          styles = _ref2.styles,\n          unhandledProps = _ref2.unhandledProps,\n          rtl = _ref2.rtl;\n      this.rtl = rtl;\n      var _this$props = this.props,\n          children = _this$props.children,\n          items = _this$props.items,\n          overflow = _this$props.overflow,\n          overflowItem = _this$props.overflowItem,\n          variables = _this$props.variables;\n\n      if (!overflow) {\n        return React.createElement(Ref, {\n          innerRef: this.containerRef\n        }, React.createElement(ElementType, _extends({\n          className: classes.root\n        }, accessibility.attributes.root, unhandledProps), React.createElement(ToolbarVariablesProvider, {\n          value: variables\n        }, childrenExist(children) ? children : this.renderItems(items))));\n      }\n\n      return React.createElement(React.Fragment, null, React.createElement(Ref, {\n        innerRef: this.containerRef\n      }, React.createElement(ElementType, _extends({\n        className: classes.root\n      }, accessibility.attributes.root, unhandledProps), React.createElement(\"div\", {\n        className: classes.overflowContainer,\n        ref: this.overflowContainerRef\n      }, React.createElement(ToolbarVariablesProvider, {\n        value: variables\n      }, childrenExist(children) ? children : this.renderItems(this.getVisibleItems()), this.renderOverflowItem(overflowItem))), React.createElement(\"div\", {\n        className: classes.offsetMeasure,\n        ref: this.offsetMeasureRef\n      }))), React.createElement(EventListener, {\n        listener: this.handleWindowResize,\n        target: this.context.target.defaultView,\n        type: \"resize\"\n      }));\n    }\n  }]);\n\n  return Toolbar;\n}(UIComponent);\n\n_defineProperty(Toolbar, \"create\", void 0);\n\n_defineProperty(Toolbar, \"className\", 'ui-toolbar');\n\n_defineProperty(Toolbar, \"displayName\", 'Toolbar');\n\n_defineProperty(Toolbar, \"propTypes\", Object.assign({}, commonPropTypes.createCommon(), {\n  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n  overflow: PropTypes.bool,\n  overflowOpen: PropTypes.bool,\n  overflowItem: customPropTypes.shorthandAllowingChildren,\n  onOverflow: PropTypes.func,\n  onOverflowOpenChange: PropTypes.func,\n  getOverflowItems: PropTypes.func\n}));\n\n_defineProperty(Toolbar, \"defaultProps\", {\n  accessibility: toolbarBehavior,\n  items: [],\n  overflowItem: {}\n});\n\n_defineProperty(Toolbar, \"CustomItem\", ToolbarCustomItem);\n\n_defineProperty(Toolbar, \"Divider\", ToolbarDivider);\n\n_defineProperty(Toolbar, \"Item\", ToolbarItem);\n\n_defineProperty(Toolbar, \"Menu\", ToolbarMenu);\n\n_defineProperty(Toolbar, \"MenuDivider\", ToolbarMenuDivider);\n\n_defineProperty(Toolbar, \"MenuItem\", ToolbarMenuItem);\n\n_defineProperty(Toolbar, \"MenuRadioGroup\", ToolbarMenuRadioGroup);\n\n_defineProperty(Toolbar, \"RadioGroup\", ToolbarRadioGroup);\n\nToolbar.create = createShorthandFactory({\n  Component: Toolbar,\n  mappedProp: 'content'\n});\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\n\nexport default withSafeTypeForAs(Toolbar);","map":{"version":3,"sources":["components/Toolbar/Toolbar.tsx"],"names":["WAS_FOCUSABLE_ATTRIBUTE","Toolbar","UIComponent","commonPropTypes","items","customPropTypes","overflow","PropTypes","bool","overflowOpen","overflowItem","shorthandAllowingChildren","onOverflow","func","onOverflowOpenChange","getOverflowItems","accessibility","ToolbarCustomItem","ToolbarDivider","ToolbarItem","ToolbarMenu","ToolbarMenuDivider","ToolbarMenuItem","ToolbarMenuRadioGroup","ToolbarRadioGroup","React","kind","defaultProps","toggleButtonBehavior","el","firstFocusableItem","getFirstFocusable","wasFocusable","itemBoundingRect","containerBoundingRect","$item","overflowItemBoundingRect","actualWindow","itemLeftMargin","parseFloat","wouldCollide","itemRightMargin","$overflowItem","$lastVisibleItem","lastVisibleItemRect","absolutePositioningOffset","lastVisibleItemMarginLeft","lastVisibleItemRightMargin","$overflowContainer","$offsetMeasure","Number","$items","overflowContainerBoundingRect","offsetMeasureBoundingRect","horizontal","vertical","top","isOverflowing","end","overflowItemRef","icon","outline","overrideProps","menu","menuOpen","onMenuOpenChange","ElementType","classes","styles","unhandledProps","rtl","children","variables","containerRef","root","childrenExist","overflowContainerRef","offsetMeasureRef","createShorthandFactory","Component","mappedProp","withSafeTypeForAs"],"mappings":"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","sourcesContent":["import { Accessibility, toolbarBehavior, toggleButtonBehavior, IS_FOCUSABLE_ATTRIBUTE } from '@fluentui/accessibility';\nimport * as React from 'react';\nimport * as _ from 'lodash';\nimport * as customPropTypes from '@fluentui/react-proptypes';\nimport * as PropTypes from 'prop-types';\nimport { Ref } from '@fluentui/react-component-ref';\nimport { EventListener } from '@fluentui/react-component-event-listener';\nimport { getFirstFocusable } from '@fluentui/react-bindings';\n\nimport {\n  childrenExist,\n  createShorthandFactory,\n  UIComponent,\n  UIComponentProps,\n  ContentComponentProps,\n  ChildrenComponentProps,\n  commonPropTypes,\n  ColorComponentProps,\n  ShorthandFactory,\n} from '../../utils';\n\nimport { ComponentEventHandler, ShorthandCollection, ShorthandValue, WithAsProp, withSafeTypeForAs } from '../../types';\n\nimport ToolbarCustomItem from './ToolbarCustomItem';\nimport ToolbarDivider from './ToolbarDivider';\nimport ToolbarItem, { ToolbarItemProps } from './ToolbarItem';\nimport ToolbarMenu from './ToolbarMenu';\nimport ToolbarMenuDivider from './ToolbarMenuDivider';\nimport ToolbarMenuItem, { ToolbarMenuItemProps } from './ToolbarMenuItem';\nimport ToolbarMenuRadioGroup from './ToolbarMenuRadioGroup';\nimport ToolbarRadioGroup from './ToolbarRadioGroup';\nimport { ToolbarVariablesProvider } from './toolbarVariablesContext';\nimport { MoreIcon } from '@fluentui/react-icons-northstar';\n\nexport type ToolbarItemShorthandKinds = 'divider' | 'item' | 'group' | 'toggle' | 'custom';\n\ntype PositionOffset = {\n  vertical: number;\n  horizontal: number;\n};\n\nconst WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';\n\nexport interface ToolbarProps\n  extends UIComponentProps,\n    ContentComponentProps,\n    ChildrenComponentProps,\n    ColorComponentProps {\n  /** Accessibility behavior if overridden by the user. */\n  accessibility?: Accessibility;\n\n  /** Shorthand array of props for Toolbar. */\n  items?: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>;\n\n  /**\n   *  Automatically move overflow items to overflow menu.\n   *  For automatic overflow to work correctly, toolbar items including overflowMenuItem\n   *  must NOT change their size! If you need to change item's size, rerender the Toolbar.\n   */\n  overflow?: boolean;\n\n  /** Indicates if the overflow menu is open. Only valid if `overflow` is enabled and regular items do not fit. */\n  overflowOpen?: boolean;\n\n  /**\n   * Shorthand for the overflow item which is displayed when `overflow` is enabled and regular toolbar items do not fit.\n   * Do not set any menu on this item, Toolbar overrides it.\n   */\n  overflowItem?: ShorthandValue<ToolbarItemProps>;\n\n  /**\n   * Called when overflow is recomputed (after render, update or window resize). Even if all items fit.\n   * @param itemsVisible - number of items visible\n   */\n  onOverflow?: (itemsVisible: number) => void;\n\n  /**\n   * Event for request to change 'overflowOpen' value.\n   * @param event - React's original SyntheticEvent.\n   * @param data - All props and proposed value.\n   */\n  onOverflowOpenChange?: ComponentEventHandler<ToolbarProps>;\n\n  /**\n   * Callback to get items to be rendered in overflow menu.\n   * Called when overflow menu is rendered opened.\n   * @param startIndex - Index of the first item to be displayed in the overflow menu (the first item which does not fit the toolbar).\n   */\n  getOverflowItems?: (startIndex: number) => ShorthandCollection<ToolbarMenuItemProps, ToolbarItemShorthandKinds>; // FIXME: use correct kind\n}\n\nclass Toolbar extends UIComponent<WithAsProp<ToolbarProps>> {\n  static create: ShorthandFactory<ToolbarProps>;\n\n  static className = 'ui-toolbar';\n\n  static displayName = 'Toolbar';\n\n  static propTypes = {\n    ...commonPropTypes.createCommon(),\n    items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),\n    overflow: PropTypes.bool,\n    overflowOpen: PropTypes.bool,\n    overflowItem: customPropTypes.shorthandAllowingChildren,\n    onOverflow: PropTypes.func,\n    onOverflowOpenChange: PropTypes.func,\n    getOverflowItems: PropTypes.func,\n  };\n\n  static defaultProps = {\n    accessibility: toolbarBehavior,\n    items: [],\n    overflowItem: {},\n  };\n\n  static CustomItem = ToolbarCustomItem;\n  static Divider = ToolbarDivider;\n  static Item = ToolbarItem;\n  static Menu = ToolbarMenu;\n  static MenuDivider = ToolbarMenuDivider;\n  static MenuItem = ToolbarMenuItem;\n  static MenuRadioGroup = ToolbarMenuRadioGroup;\n  static RadioGroup = ToolbarRadioGroup;\n\n  overflowContainerRef = React.createRef<HTMLDivElement>();\n  overflowItemRef = React.createRef<HTMLElement>();\n  offsetMeasureRef = React.createRef<HTMLDivElement>();\n  containerRef = React.createRef<HTMLElement>();\n\n  // index of the last visible item in Toolbar, the rest goes to overflow menu\n  lastVisibleItemIndex: number;\n\n  animationFrameId: number;\n  rtl: boolean;\n\n  renderItems(items: ShorthandCollection<ToolbarItemProps, ToolbarItemShorthandKinds>) {\n    return _.map(items, (item: ShorthandValue<ToolbarItemProps & { kind?: ToolbarItemShorthandKinds }>) => {\n      const kind = _.get(item, 'kind', 'item');\n\n      switch (kind) {\n        case 'divider':\n          return ToolbarDivider.create(item);\n        case 'group':\n          return ToolbarRadioGroup.create(item);\n        case 'toggle':\n          return ToolbarItem.create(item, {\n            defaultProps: () => ({ accessibility: toggleButtonBehavior }),\n          });\n        case 'custom':\n          return ToolbarCustomItem.create(item);\n        default:\n          return ToolbarItem.create(item);\n      }\n    });\n  }\n\n  hide(el: HTMLElement) {\n    if (el.style.visibility === 'hidden') {\n      return;\n    }\n\n    if (this.context.target.activeElement === el || el.contains(this.context.target.activeElement)) {\n      if (this.containerRef.current) {\n        const firstFocusableItem = getFirstFocusable(\n          this.containerRef.current,\n          this.containerRef.current.firstElementChild as HTMLElement,\n        );\n\n        if (firstFocusableItem) {\n          firstFocusableItem.focus();\n        }\n      }\n    }\n\n    el.style.visibility = 'hidden';\n    const wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n    }\n    el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');\n  }\n\n  show(el: HTMLElement) {\n    if (el.style.visibility !== 'hidden') {\n      return false;\n    }\n\n    el.style.visibility = null;\n    const wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    if (wasFocusable) {\n      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);\n      el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);\n    } else {\n      el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks if `item` overflows a `container`.\n   * TODO: check and fix all margin combination\n   */\n  isItemOverflowing(itemBoundingRect: ClientRect, containerBoundingRect: ClientRect) {\n    return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;\n  }\n\n  /**\n   * Checks if `item` would collide with eventual position of `overflowItem`.\n   */\n  wouldItemCollide(\n    $item: Element,\n    itemBoundingRect: ClientRect,\n    overflowItemBoundingRect: ClientRect,\n    containerBoundingRect: ClientRect,\n  ) {\n    const actualWindow: Window = this.context.target.defaultView;\n    let wouldCollide;\n\n    if (this.rtl) {\n      const itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;\n      wouldCollide =\n        itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left;\n\n      // console.log('Collision [RTL]', {\n      //   wouldCollide,\n      //   'itemBoundingRect.left': itemBoundingRect.left,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin: itemLeftMargin,\n      //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,\n      //   'overflowContainerBoundingRect.left': containerBoundingRect.left,\n      // })\n    } else {\n      const itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;\n      wouldCollide =\n        itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right;\n\n      // console.log('Collision', {\n      //   wouldCollide,\n      //   'itemBoundingRect.right': itemBoundingRect.right,\n      //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,\n      //   itemRightMargin,\n      //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,\n      //   'overflowContainerBoundingRect.right': containerBoundingRect.right,\n      // })\n    }\n\n    return wouldCollide;\n  }\n\n  /**\n   * Positions overflowItem next to lastVisible item\n   * TODO: consider overflowItem margin\n   */\n  setOverflowPosition(\n    $overflowItem: HTMLElement,\n    $lastVisibleItem: HTMLElement | undefined,\n    lastVisibleItemRect: ClientRect | undefined,\n    containerBoundingRect: ClientRect,\n    absolutePositioningOffset: PositionOffset,\n  ) {\n    const actualWindow: Window = this.context.target.defaultView;\n\n    if ($lastVisibleItem) {\n      if (this.rtl) {\n        const lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;\n\n        $overflowItem.style.right = `${containerBoundingRect.right -\n          lastVisibleItemRect.left +\n          lastVisibleItemMarginLeft +\n          absolutePositioningOffset.horizontal}px`;\n      } else {\n        const lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;\n\n        $overflowItem.style.left = `${lastVisibleItemRect.right -\n          containerBoundingRect.left +\n          lastVisibleItemRightMargin +\n          absolutePositioningOffset.horizontal}px`;\n      }\n    } else {\n      // there is no last visible item -> position the overflow as the first item\n      this.lastVisibleItemIndex = -1;\n      if (this.rtl) {\n        $overflowItem.style.right = `${absolutePositioningOffset.horizontal}px`;\n      } else {\n        $overflowItem.style.left = `${absolutePositioningOffset.horizontal}px`;\n      }\n    }\n  }\n\n  hideOverflowItems = () => {\n    const $overflowContainer = this.overflowContainerRef.current;\n    const $overflowItem = this.overflowItemRef.current;\n    const $offsetMeasure = this.offsetMeasureRef.current;\n    if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {\n      return;\n    }\n\n    // workaround: when resizing window with popup opened the container contents scroll for some reason\n    if (this.rtl) {\n      $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);\n    } else {\n      $overflowContainer.scrollTo(0, 0);\n    }\n\n    const $items = $overflowContainer.children;\n\n    const overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();\n    const overflowItemBoundingRect = $overflowItem.getBoundingClientRect();\n    const offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect();\n\n    // Absolute positioning offset\n    // Overflow menu is absolutely positioned relative to root slot\n    // If there is padding set on the root slot boundingClientRect computations use inner content box,\n    // but absolute position is relative to root slot's PADDING box.\n    // We compute absolute positioning offset\n    // By measuring position of an offsetMeasure element absolutely positioned to 0,0.\n    // TODO: replace by getComputedStyle('padding')\n    const absolutePositioningOffset: PositionOffset = {\n      horizontal: this.rtl\n        ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right\n        : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,\n      vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top,\n    };\n\n    let isOverflowing = false;\n    let $lastVisibleItem;\n    let lastVisibleItemRect;\n\n    // check all items from the last one back\n    _.forEachRight($items, ($item: HTMLElement, i: number) => {\n      if ($item === $overflowItem) {\n        return true;\n      }\n\n      const itemBoundingRect = $item.getBoundingClientRect();\n\n      // if the item is out of the crop rectangle, hide it\n      if (this.isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {\n        isOverflowing = true;\n        // console.log('Overflow', i, {\n        //   item: [itemBoundingRect.left, itemBoundingRect.right],\n        //   crop: [\n        //     overflowContainerBoundingRect.left,\n        //     overflowContainerBoundingRect.right,\n        //     overflowContainerBoundingRect.width,\n        //   ],\n        //   container: $overflowContainer,\n        // })\n        this.hide($item);\n        return true;\n      }\n\n      // if there is an overflow, check collision of remaining items with eventual overflow position\n      if (\n        isOverflowing &&\n        !$lastVisibleItem &&\n        this.wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)\n      ) {\n        this.hide($item);\n        return true;\n      }\n\n      // Remember the last visible item\n      if (!$lastVisibleItem) {\n        $lastVisibleItem = $item;\n        lastVisibleItemRect = itemBoundingRect;\n        this.lastVisibleItemIndex = i;\n      }\n\n      return this.show($item); // exit the loop when first visible item is found\n    });\n\n    // if there is an overflow,  position and show overflow item, otherwise hide it\n    if (isOverflowing || this.props.overflowOpen) {\n      $overflowItem.style.position = 'absolute';\n      this.setOverflowPosition(\n        $overflowItem,\n        $lastVisibleItem,\n        lastVisibleItemRect,\n        overflowContainerBoundingRect,\n        absolutePositioningOffset,\n      );\n      this.show($overflowItem);\n    } else {\n      this.lastVisibleItemIndex = this.props.items.length - 1;\n      this.hide($overflowItem);\n    }\n\n    _.invoke(this.props, 'onOverflow', this.lastVisibleItemIndex + 1);\n  };\n\n  getOverflowItems = () => {\n    // console.log('getOverflowItems()', this.props.items.slice(this.lastVisibleItemIndex + 1))\n    return this.props.getOverflowItems\n      ? this.props.getOverflowItems(this.lastVisibleItemIndex + 1)\n      : this.props.items.slice(this.lastVisibleItemIndex + 1);\n  };\n\n  getVisibleItems = () => {\n    // console.log('allItems()', this.props.items)\n    const end = this.props.overflowOpen ? this.lastVisibleItemIndex + 1 : this.props.items.length;\n    // console.log('getVisibleItems()', this.props.items.slice(0, end))\n    return this.props.items.slice(0, end);\n  };\n\n  componentDidMount() {\n    this.afterComponentRendered();\n  }\n\n  componentDidUpdate() {\n    this.afterComponentRendered();\n  }\n\n  componentWillUnmount() {\n    if (this.animationFrameId !== undefined) {\n      this.context.target.defaultView.cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = undefined;\n    }\n  }\n\n  afterComponentRendered() {\n    const actualWindow: Window = this.context.target.defaultView;\n\n    if (this.animationFrameId !== undefined) {\n      actualWindow.cancelAnimationFrame(this.animationFrameId);\n    }\n\n    // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary\n    this.animationFrameId = actualWindow.requestAnimationFrame(() => {\n      this.hideOverflowItems();\n    });\n  }\n\n  handleWindowResize = _.debounce((e: UIEvent) => {\n    this.hideOverflowItems();\n\n    if (this.props.overflowOpen) {\n      _.invoke(this.props, 'onOverflowOpenChange', e, {\n        ...this.props,\n        overflowOpen: false,\n      });\n    }\n  }, 16);\n\n  renderOverflowItem(overflowItem) {\n    return (\n      <Ref innerRef={this.overflowItemRef}>\n        {ToolbarItem.create(overflowItem, {\n          defaultProps: () => ({\n            // TODO: ups\n            icon: <MoreIcon {...{ outline: true }} />,\n          }),\n          overrideProps: {\n            menu: this.props.overflowOpen ? this.getOverflowItems() : [],\n            menuOpen: this.props.overflowOpen,\n            onMenuOpenChange: (e, { menuOpen }) => {\n              _.invoke(this.props, 'onOverflowOpenChange', e, {\n                ...this.props,\n                overflowOpen: menuOpen,\n              });\n            },\n          },\n        })}\n      </Ref>\n    );\n  }\n\n  renderComponent({ accessibility, ElementType, classes, styles, unhandledProps, rtl }): React.ReactNode {\n    this.rtl = rtl;\n    const { children, items, overflow, overflowItem, variables } = this.props;\n\n    if (!overflow) {\n      return (\n        <Ref innerRef={this.containerRef}>\n          <ElementType className={classes.root} {...accessibility.attributes.root} {...unhandledProps}>\n            <ToolbarVariablesProvider value={variables}>\n              {childrenExist(children) ? children : this.renderItems(items)}\n            </ToolbarVariablesProvider>\n          </ElementType>\n        </Ref>\n      );\n    }\n\n    return (\n      <>\n        <Ref innerRef={this.containerRef}>\n          <ElementType className={classes.root} {...accessibility.attributes.root} {...unhandledProps}>\n            <div className={classes.overflowContainer} ref={this.overflowContainerRef}>\n              <ToolbarVariablesProvider value={variables}>\n                {childrenExist(children) ? children : this.renderItems(this.getVisibleItems())}\n                {this.renderOverflowItem(overflowItem)}\n              </ToolbarVariablesProvider>\n            </div>\n            <div className={classes.offsetMeasure} ref={this.offsetMeasureRef} />\n          </ElementType>\n        </Ref>\n        <EventListener listener={this.handleWindowResize} target={this.context.target.defaultView} type=\"resize\" />\n      </>\n    );\n  }\n}\n\nToolbar.create = createShorthandFactory({ Component: Toolbar, mappedProp: 'content' });\n\n/**\n * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).\n *\n * @accessibility\n *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.\n * @accessibilityIssues\n * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)\n */\nexport default withSafeTypeForAs<typeof Toolbar, ToolbarProps>(Toolbar);\n"]},"metadata":{},"sourceType":"module"}