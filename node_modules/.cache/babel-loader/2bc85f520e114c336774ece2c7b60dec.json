{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar PlacementParts;\n\n(function (PlacementParts) {\n  PlacementParts[\"top\"] = \"top\";\n  PlacementParts[\"bottom\"] = \"bottom\";\n  PlacementParts[\"start\"] = \"start\";\n  PlacementParts[\"end\"] = \"end\";\n  PlacementParts[\"left\"] = \"left\";\n  PlacementParts[\"right\"] = \"right\";\n  PlacementParts[\"center\"] = \"\";\n})(PlacementParts || (PlacementParts = {}));\n\nvar getPositionMap = function getPositionMap(rtl) {\n  return {\n    above: PlacementParts.top,\n    below: PlacementParts.bottom,\n    before: rtl ? PlacementParts.right : PlacementParts.left,\n    after: rtl ? PlacementParts.left : PlacementParts.right\n  };\n};\n\nvar getAlignmentMap = function getAlignmentMap(rtl) {\n  return {\n    start: rtl ? PlacementParts.end : PlacementParts.start,\n    end: rtl ? PlacementParts.start : PlacementParts.end,\n    top: PlacementParts.start,\n    bottom: PlacementParts.end,\n    center: PlacementParts.center\n  };\n};\n\nvar shouldAlignToCenter = function shouldAlignToCenter(p, a) {\n  var positionedVertically = p === 'above' || p === 'below';\n  var alignedVertically = a === 'top' || a === 'bottom';\n  return positionedVertically && alignedVertically || !positionedVertically && !alignedVertically;\n};\n/**\n * | position | alignment | placement       | placement RTL\n * -----------------------------------------------------------------\n * | above    | start     |  top-start      |  top-end\n * | above    | center    |  top            |  top\n * | above    | end       |  top-end        |  top-start\n * | below    | start     |  bottom-start   |  bottom-end\n * | below    | center    |  bottom         |  bottom\n * | below    | end       |  bottom-end     |  bottom-start\n * | before   | top       |  left-start     |  right-start\n * | before   | center    |  left           |  right\n * | before   | bottom    |  left-end       |  right-end\n * | after    | top       |  right-start    |  left-start\n * | after    | center    |  right          |  left\n * | after    | bottom    |  right-end      |  left-end\n */\n\n\nexport var getPlacement = function getPlacement(_ref) {\n  var align = _ref.align,\n      position = _ref.position,\n      rtl = _ref.rtl;\n  var alignment = shouldAlignToCenter(position, align) ? 'center' : align;\n  var computedPosition = getPositionMap(rtl)[position];\n  var computedAlignmnent = getAlignmentMap(rtl)[alignment];\n  var stringifiedAlignment = computedAlignmnent && \"-\".concat(computedAlignmnent);\n  return \"\".concat(computedPosition).concat(stringifiedAlignment);\n}; //\n// OFFSET VALUES ADJUSTMENT\n//\n\nvar flipPlusMinusSigns = function flipPlusMinusSigns(offset) {\n  return offset.replace(/\\-/g, '<plus>').replace(/^(\\s*)(?=\\d)/, '<minus>').replace(/\\+/g, '<minus>').replace(/<plus>/g, '+').replace(/<minus>/g, '-').trimLeft().replace(/^\\+/, '');\n};\n\nexport var applyRtlToOffset = function applyRtlToOffset(offset, position) {\n  if (position === 'above' || position === 'below') {\n    var _offset$split = offset.split(','),\n        _offset$split2 = _slicedToArray(_offset$split, 2),\n        horizontal = _offset$split2[0],\n        vertical = _offset$split2[1];\n\n    return [flipPlusMinusSigns(horizontal), vertical].join(', ').replace(/, $/, '').trim();\n  }\n\n  return offset;\n};","map":{"version":3,"sources":["utils/positioner/positioningHelper.ts"],"names":["PlacementParts","getPositionMap","above","below","before","rtl","after","right","getAlignmentMap","start","end","top","bottom","center","shouldAlignToCenter","positionedVertically","p","alignedVertically","a","getPlacement","align","position","alignment","computedPosition","computedAlignmnent","stringifiedAlignment","flipPlusMinusSigns","offset","applyRtlToOffset","horizontal","vertical"],"mappings":"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","sourcesContent":["import { Placement } from 'popper.js';\n\nimport { Alignment, Position } from './types';\n\nenum PlacementParts {\n  top = 'top',\n  bottom = 'bottom',\n  start = 'start',\n  end = 'end',\n  left = 'left',\n  right = 'right',\n  center = '',\n}\n\nconst getPositionMap = (rtl: boolean): Record<Position, PlacementParts> => ({\n  above: PlacementParts.top,\n  below: PlacementParts.bottom,\n  before: rtl ? PlacementParts.right : PlacementParts.left,\n  after: rtl ? PlacementParts.left : PlacementParts.right,\n});\n\nconst getAlignmentMap = (rtl: boolean): Record<Alignment, PlacementParts> => ({\n  start: rtl ? PlacementParts.end : PlacementParts.start,\n  end: rtl ? PlacementParts.start : PlacementParts.end,\n  top: PlacementParts.start,\n  bottom: PlacementParts.end,\n  center: PlacementParts.center,\n});\n\nconst shouldAlignToCenter = (p: Position, a: Alignment) => {\n  const positionedVertically = p === 'above' || p === 'below';\n  const alignedVertically = a === 'top' || a === 'bottom';\n\n  return (positionedVertically && alignedVertically) || (!positionedVertically && !alignedVertically);\n};\n\n/**\n * | position | alignment | placement       | placement RTL\n * -----------------------------------------------------------------\n * | above    | start     |  top-start      |  top-end\n * | above    | center    |  top            |  top\n * | above    | end       |  top-end        |  top-start\n * | below    | start     |  bottom-start   |  bottom-end\n * | below    | center    |  bottom         |  bottom\n * | below    | end       |  bottom-end     |  bottom-start\n * | before   | top       |  left-start     |  right-start\n * | before   | center    |  left           |  right\n * | before   | bottom    |  left-end       |  right-end\n * | after    | top       |  right-start    |  left-start\n * | after    | center    |  right          |  left\n * | after    | bottom    |  right-end      |  left-end\n */\nexport const getPlacement = ({\n  align,\n  position,\n  rtl,\n}: {\n  align: Alignment;\n  position: Position;\n  rtl: boolean;\n}): Placement => {\n  const alignment: Alignment = shouldAlignToCenter(position, align) ? 'center' : align;\n  const computedPosition = getPositionMap(rtl)[position];\n  const computedAlignmnent = getAlignmentMap(rtl)[alignment];\n  const stringifiedAlignment = computedAlignmnent && `-${computedAlignmnent}`;\n\n  return `${computedPosition}${stringifiedAlignment}` as Placement;\n};\n\n//\n// OFFSET VALUES ADJUSTMENT\n//\n\nconst flipPlusMinusSigns = (offset: string): string => {\n  return offset\n    .replace(/\\-/g, '<plus>')\n    .replace(/^(\\s*)(?=\\d)/, '<minus>')\n    .replace(/\\+/g, '<minus>')\n    .replace(/<plus>/g, '+')\n    .replace(/<minus>/g, '-')\n    .trimLeft()\n    .replace(/^\\+/, '');\n};\n\nexport const applyRtlToOffset = (offset: string, position: Position): string => {\n  if (position === 'above' || position === 'below') {\n    const [horizontal, vertical] = offset.split(',');\n    return [flipPlusMinusSigns(horizontal), vertical]\n      .join(', ')\n      .replace(/, $/, '')\n      .trim();\n  }\n\n  return offset;\n};\n"]},"metadata":{},"sourceType":"module"}